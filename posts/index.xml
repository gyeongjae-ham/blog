<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 안녕루카</title>
    <link>https://hiyee-gj.github.io/blog/posts/</link>
    <description>Recent content in Posts on 안녕루카</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 02 May 2023 11:08:32 +0900</lastBuildDate><atom:link href="https://hiyee-gj.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 코테 팁 정리</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230503_java_%EC%BD%94%ED%85%8C_%ED%8C%81_%EC%A0%95%EB%A6%AC/</link>
      <pubDate>Tue, 02 May 2023 11:08:32 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230503_java_%EC%BD%94%ED%85%8C_%ED%8C%81_%EC%A0%95%EB%A6%AC/</guid>
      <description>이 포스트는 Java 언어로 알고리즘을 풀면서 자주 사용하는 함수의 내용을 정리하는 포스트입니다.
ArrayList 깊은 복사 ArrayList를 깊은 복사하고 싶다면 복사되는배열.addAll(복사할배열) 메서드를 사용하면 된다 ArrayList&amp;lt;Integer&amp;gt; w=new ArrayList&amp;lt;Integer&amp;gt;(); ArrayList&amp;lt;Integer&amp;gt; copy_w=new ArrayList&amp;lt;Integer&amp;gt;(); copy_w.addAll(w); Sort ArrayList를 정렬할 때, 리스트명.sort() 메소드를 사용한다 ArrayList&amp;lt;Integer&amp;gt; ArrList=new ArrayList&amp;lt;Integer&amp;gt;(); ArrList.sort(null); Size ArrayList의 크기는 리스트명.size() 메소드를 사용한다 ArrayList&amp;lt;Integer&amp;gt; ArrList=new ArrayList&amp;lt;Integer&amp;gt;(); ArrList.size(); List Set =&amp;gt; List 변경 생성자에 값을 넣어주면, Set -&amp;gt; List로 변경할 수 있다 Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(); List&amp;lt;String&amp;gt; menuList = new ArrayList&amp;lt;&amp;gt;(set); Sort List를 정렬하고자 할 때, Collections.</description>
    </item>
    
    <item>
      <title>Python답게</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230502_python%EB%8B%B5%EA%B2%8C/</link>
      <pubDate>Tue, 02 May 2023 11:08:32 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230502_python%EB%8B%B5%EA%B2%8C/</guid>
      <description>이 포스트는 알고리즘을 풀면서 Python 언어의 장점을 극대화해서 효율적으로 해결하기 위해서 학습한 내용을 모아놓은 포스트입니다
몫과 나머지 print(a // b, a % b) ==&amp;gt; print(*divmod(a, b)) 무조건 divmod를 사용하는 게 좋은 방법은 아닙니다.
divmod는 작은 숫자를 다룰 때는 a//b, a%b 보다 느립니다. 대신, 큰 숫자를 다룰 때는 더 빠릅니다
n진법으로 표기된 string을 10진법 숫자로 변환하기 int(x, base=진법) # ex) num = &amp;#39;3212&amp;#39; base = 5 ans = int(num, base) 문자열 정렬하기 s = &amp;#39;가나다라&amp;#39; n = 7 s.</description>
    </item>
    
    <item>
      <title>@Mock, @MockBean</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230424_@mock_@mockbean/</link>
      <pubDate>Mon, 24 Apr 2023 23:06:29 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230424_@mock_@mockbean/</guid>
      <description>@Mock과 @MockBean Mock 객체를 선언할 때 쓰이는 어노테이션
Spring의 ApplicationContext에 Mock 객체들을 넣어준다
@Mock import org.mockito.Mock @MockBean import org.springframework.boo.test.mock.mockito.MockBean 스프링 테스트에서 지원 Spring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 @MockBean을 사용하고 아닌 경우에는 @Mock을 사용한다
@Mock 필드명에 @Mock을 선언해주어 에러검증을 쉽게 하고, 해당 필드가 Mock 객체임을 더 명확하게 표시한다
Service 레이어 테스트할 때, Repository를 가짜 객체로 만드는 용도로 사용될 수 있다.
@MockBean **@WebMvcTest**를 이용한 테스트에서 사용할 수 있다.</description>
    </item>
    
    <item>
      <title>Test Double</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230424_test_double/</link>
      <pubDate>Mon, 24 Apr 2023 22:23:00 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230424_test_double/</guid>
      <description>Mock 이란 가짜 객체라고 불리며, 객체의 행위를 검증하기 위해 사용되는 가짜 객체이다
가짜 객체를 만드는 이유 실제 객체를 만드는데 드는 시간을 절약하고, 의존성의 연결고리가 많이 연결된 경우에 구현의 복잡함을 피하고 간단하게 테스트 검증을 하기 위해서 쓴다
Test Double 테스트 더블은 영화를 촬영할 때 배우를 대신하여 위험한 역할을 하는 스턴트 더블이라는 용어에서 유래된 단어이다
자동화된 테스트를 작성할 때, 여러 객체들이 의존성을 갖는 경우 테스트하기 까다로운 경우가 있다. 예를 들어서 프로덕션 코드에서 Service layer는 DAO에 직접적으로 의존하고, 따라서 Database까지 의존하는 형태를 갖는다</description>
    </item>
    
    <item>
      <title>Controller 테스트 작성</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230422_controller_%ED%85%8C%EC%8A%A4%ED%8A%B8/</link>
      <pubDate>Sat, 22 Apr 2023 18:41:45 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230422_controller_%ED%85%8C%EC%8A%A4%ED%8A%B8/</guid>
      <description>Controller 테스트 작성 @WebMvcTest Application을 완전하게 시작학지 않고, Web layer를 테스트하고 싶을 때 @WebMvcTest를 사용한다.
MockMvc 애플리케이션을 배포하지 않고도, 서버의 MVC 동작을 테스트하게 해주는 라이브러리다. 주로 Controller 레이어 테스트에 많이 사용된다.
테스트 이름 정하기 테스트마다 이름에 테스트하는 조건을 넣기 때문에 따로 @DisplayName을 설정하지 않을 수도 있지만 보다 구분하기 쉽고 명확하게 하기 위해서 사용하는 것을 고려해보는게 좋다고 생각한다.
@DisplayName(&amp;#34;[view][GET] 게시글 리스트 (게시판) 페이지 - 정상 호출&amp;#34;) 팀마다 이름 규칙을 정해서 맨 앞 부분만 보더라도 어디를 어떤 테스트를 하는 건지 구분짓는 것도 좋은 방법같다.</description>
    </item>
    
    <item>
      <title>QueryDSL 설정 방법</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230421_querydsl/</link>
      <pubDate>Fri, 21 Apr 2023 09:37:03 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230421_querydsl/</guid>
      <description>QueryDSL 이란 QueryDSL은 HQL(Hibernate Query Language) 쿼리를 타입에 맞게 생성 및 관리할 수 있도록 도와주는 역할을 한다. SQL을 자바 코드처럼 작성할 수 있도록 해 준다
특징 문자가 아닌 코드로 쿼리를 작성하기 때문에 컴파일 시점에서 문법 오류 발견이 된다 자동완성 등 IDE의 도움을 받을 수 있다 동적 쿼리 작성이 편리하다(여러 방법들 중에서 압도적을로 좋은 부분) 쿼리 작성 시 제약 조건 등을 메서드 화해서 재사용할 수 있다 도메인 타입과 프로퍼티를 안전하게 참조할 수 있으며, 도메인 타입의 리팩터링을 더 잘할 수 있다 아쉽게도 QueryDSL은 Spring Initializr 페이지에서는 추가할 수 없고, 직접 설치해줘야 하는데 이 때 gradle 플러그인으로 설치하는 간단한 방법은 추천하지 않는다.</description>
    </item>
    
    <item>
      <title>application.yml과 build.gradle 설명</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230420_application.yml/</link>
      <pubDate>Thu, 20 Apr 2023 17:59:38 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230420_application.yml/</guid>
      <description>debug: false # debug 전체 true 하면 너무 정보가 많아서 복잡하니까 꺼주고 # Actuator 감춰져 있는 모든 endpoint 보는 설정 # 궁금하면 찾아보도록 하자 management.endpoints.web.exposure.include: &amp;#34;*&amp;#34; # log 설정 logging: level: # 루트 패키지에서 발생하는 모든 로그들은 debug 레벨로 보겠다 com.fastcampus.springboard: debug # request, response만 볼 수 있도록 web.servlet만 debug로 켜준다 org.springframework.web.servlet: debug # jpa 사용할 때 query log를 볼 때 binding parameter들을 보기 위한 설정(기본은 ?로 표현됨) org.hibernate.type.descriptor.sql.BasicBinder: trace spring: datasource: url: jdbc:mysql://localhost:3306/board username: hiyee password: slfl4861 driver-class-name: com.</description>
    </item>
    
    <item>
      <title>@DataJpaTest 기능</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230420_@datajpatest/</link>
      <pubDate>Thu, 20 Apr 2023 17:28:15 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230420_@datajpatest/</guid>
      <description>인메모리 DB를 이용한 Test Repository 를 이용한 테스트를 진행할 때 인메모리 DB를 많이 사용한다. 많은 방법 중 크게 2가지 정도가 자주 사용된다고 생각한다.
@SpringBootTest + 인메모리 DB 연결 @DataJpaTest 두 방법의 차이 @DataJpaTest 는 안을 들어가 보면
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @BootstrapWith(DataJpaTestContextBootstrapper.class) @ExtendWith(SpringExtension.class) @OverrideAutoConfiguration(enabled = false) @TypeExcludeFilters(DataJpaTypeExcludeFilter.class) @Transactional @AutoConfigureCache @AutoConfigureDataJpa @AutoConfigureTestDatabase @AutoConfigureTestEntityManager @ImportAutoConfiguration meta annotation 중에서 @Transactional 이 들어가 있다. 따라서 @DataJpaTest 이 붙어있는 클래스 밑의 메서드들은 실행 시 트랜잭션이 동작하기 때문에 기본적으로 롤백된다고 보면 된다.</description>
    </item>
    
    <item>
      <title>SpringBoot JPA로 Entity 클래스 구성하기</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230419_jpa%EB%A1%9C_entity/</link>
      <pubDate>Wed, 19 Apr 2023 20:42:57 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230419_jpa%EB%A1%9C_entity/</guid>
      <description>자주 사용하다보면 익숙하게 익혀지겠지만, 그래도 기록으로 남겨서 빠르게 와서 복습할 수 있도록 자세하게 남겨보도록 하려한다.
package com.fastcampus.springboard.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import org.springframework.data.annotation.CreatedBy; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedBy; import org.springframework.data.annotation.LastModifiedDate; import javax.persistence.*; import java.time.LocalDateTime; import java.util.LinkedHashSet; import java.util.Objects; import java.util.Set; @Getter // 전체 레벨에서는 Setter를 설정하지 말자(데이터 보호를 위해서 필요한 값만) @ToString // 쉽게 볼 수 있도록 @Table(indexes = { // 빠르게 검색할 수 있도록 인덱스 설정 @Index(columnList = &amp;#34;title&amp;#34;), @Index(columnList = &amp;#34;hashtag&amp;#34;), @Index(columnList = &amp;#34;createdAt&amp;#34;), @Index(columnList = &amp;#34;createdBy&amp;#34;), }) // Entity에도 Auditing을 사용한다는 설정을 해줘야 한다.</description>
    </item>
    
    <item>
      <title>JPA Auditing</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230419_jpa_auditing/</link>
      <pubDate>Wed, 19 Apr 2023 20:18:08 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230419_jpa_auditing/</guid>
      <description>Java에서 ORM 기술인 JPA 를 사용해서 도메인(엔티티)을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 예를 들면 생성일자, 생성자, 수정일자, 수정자 등의 필드 및 컬럼이 있다.
도메인마다 공통적으로 필요하다면 결국 코드가 중복으로 작성될 수밖에 없게 되고 중복을 무척이나 싫어하는 개발자들은 이 문제를 해결하기 위해서 JPA Auditing 이라는 기능을 개발하게 됩니다.
Audit 은 감시하다, 감사하다 라는 뜻으로 Spring Date JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능이다. 도메인(엔티티)을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update 하는 경우 매번 시간 데이터를 입력해 줘야 하는데, 이 기능을 사용하면 자동으로 시간을 매핑해서 테이블에 넣어준다.</description>
    </item>
    
    <item>
      <title>SpringBoot Actuator</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230419_spring_actuator/</link>
      <pubDate>Wed, 19 Apr 2023 13:12:04 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230419_spring_actuator/</guid>
      <description>웹 개발을 하면서 어플리케이션을 만들 때 서비스 로직뿐만 아니라 사용자의 정보라던지 어떤 경로로 요청이 들어오는지 등 많은 것을 고려하고 개발해야 한다. spring-boot-actuator라는 모듈은 애플리케이션 상태를 종합적으로 정리해서 보여준다.
Spring Boot Actuator 간단히 말하자면 Spring Boot Application의 상태를 관리해준다.
Spring Boot Application의 상태정보(health, properties, beans, 구동된 AutoConfiguration 목록 등)을 다룰 수 있도록 자동으로 설정 각종 추상화 클래스(HealthIndicator 등)을 제공하여, 상태 정보를 변경할 수 있도록 Service 제공 노출할 항목 설정 # Actuator 감춰져 있는 모든 endpoint 정보 표출하도록 설정 management.</description>
    </item>
    
    <item>
      <title>코테 공부 - 기초</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230418_%EC%BD%94%ED%85%8C_%EA%B3%B5%EB%B6%80_%EA%B8%B0%EC%B4%88/</link>
      <pubDate>Tue, 18 Apr 2023 17:21:06 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230418_%EC%BD%94%ED%85%8C_%EA%B3%B5%EB%B6%80_%EA%B8%B0%EC%B4%88/</guid>
      <description>오늘부터 알고리즘과 코딩테스트 공부를 하면서 기록을 남겨보려고 한다 이 기록은 그냥 스스로 리뷰하기 위한 용도이므로 만약에라도 보시는 분들의 실력이 출중하시다면 볼 필요가 없는 글입니다.
시간 복잡도 문제 해결에 소요되는 시간을 말한다
Big-O 표기법 시간 복잡도를 표현하는 표기법
보다시피 N의 값이 커질수록 수행시간은 비약적으로 커지므로 문제 제한 시간에 맞는 풀이법을 찾아서 풀어야한다. 어떤 알고리즘의 최소 시간과 최대 시간을 대략적으로 알고 있다면 문제해결에 서택할 알고리즘을 선택하는데 도움이 된다.
공간 복잡도 문제를 푸는데 필요한 공간의 크기</description>
    </item>
    
    <item>
      <title>블로그를 분리하는 이유</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230417_%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC_%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94_%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 17 Apr 2023 20:50:36 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230417_%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC_%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94_%EC%9D%B4%EC%9C%A0/</guid>
      <description>Java의 정석 다시보기 멋쟁이 사자처럼 백엔드 스쿨 5기에 합격하게 되면서 Java와 Spring에 대해서 다시 찐하게 공부할 수 있는 기회를 얻게 되었다. 사실 혼자서도 공부를 지속할 수 있었겠지만 최근 알고리즘과 코딩테스트 준비로 반복적으로 문제만 풀다 보니 뭔가 의지력이 점점 소모되는게 느껴져서 더 통제되는 환경에 나를 던져놓고 나를 성장시키고 싶었는데 운이 좋게도 합격하게 되어 공부에 열정을 다시 불태울 수 있는 기회가 됐다.
사실 자바의 정석은 작년 이맘 때쯤 좋은 스터디원 분들과 한번 1회독을 마친 책이다.</description>
    </item>
    
  </channel>
</rss>
