[{"content":"자주 사용하다보면 익숙하게 익혀지겠지만, 그래도 기록으로 남겨서 빠르게 와서 복습할 수 있도록 자세하게 남겨보도록 하려한다.\npackage com.fastcampus.springboard.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import org.springframework.data.annotation.CreatedBy; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedBy; import org.springframework.data.annotation.LastModifiedDate; import javax.persistence.*; import java.time.LocalDateTime; import java.util.LinkedHashSet; import java.util.Objects; import java.util.Set; @Getter // 전체 레벨에서는 Setter를 설정하지 말자(데이터 보호를 위해서 필요한 값만) @ToString // 쉽게 볼 수 있도록 @Table(indexes = { // 빠르게 검색할 수 있도록 인덱스 설정 @Index(columnList = \u0026#34;title\u0026#34;), @Index(columnList = \u0026#34;hashtag\u0026#34;), @Index(columnList = \u0026#34;createdAt\u0026#34;), @Index(columnList = \u0026#34;createdBy\u0026#34;), }) // Entity에도 Auditing을 사용한다는 설정을 해줘야 한다. @EntityListeners(AuditingEntityListener.class) @Entity public class Article { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Setter @Column(nullable = false) private String title; // 제목 @Setter @Column(nullable = false, length = 10000) // nullable = true가 기본설정 private String content; // 본문 // @Column은 기본 설정을 변경하는 경우가 아니라면 생략이 가능하다 @Setter private String hashtag; // 해시태그 // Jpa 양방향 설정 // mappedBy를 하지 않으면 양방향 관계의 두 테이블명을 합쳐서 테이블을 생성한다 // mappedBy로 article 테이블로부터 온 것이라고 표시해 주기 @ToString.Exclude // 순환 참조의 가능성이 있으므로 양방향 중에서 보통 one의 쪽에서 끊어준다 @OrderBy(\u0026#34;id\u0026#34;) @OneToMany(mappedBy = \u0026#34;article\u0026#34;, cascade = CascadeType.ALL) private final Set\u0026lt;ArticleComment\u0026gt; articleComments = new LinkedHashSet\u0026lt;\u0026gt;(); @CreatedDate @Column(nullable = false) private LocalDateTime createdAt; // 생성일시 @CreatedBy @Column(nullable = false, length = 100) private String createdBy; // 생성자 @LastModifiedDate @Column(nullable = false) private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy @Column(nullable = false, length = 100) private String modifiedBy; // 수정자 protected Article() { } // private 제어자로 막아놓고 팩토리 메서드로 편리하게 바로 생성하자 private Article(String title, String content, String hashtag) { this.title = title; this.content = content; this.hashtag = hashtag; } // 팩토리 메서드 public static Article of(String title, String content, String hashtag) { return new Article(title, content, hashtag); } // 그냥 lombok의 EqualsAndHashCode를 사용하면 전체 필드를 비교하기 때문에 // Entity 클래스에서는 고유값인 id만 가지고 비교하기 위해서 따로 생성해 줌 @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Article article)) return false; return id != null \u0026amp;\u0026amp; id.equals(article.id); } @Override public int hashCode() { return Objects.hash(id); } } 다른 설정들은 위 클래스를 찬찬히 보면서 기능을 익히면 되고 equals and hash 를 구현한 부분에서\n@Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Article article)) return false; return id != null \u0026amp;\u0026amp; id.equals(article.id); } 이 부분에서 if (!(o instanceof Article article)) 이 부분은 java 14 에서 추가된 pattern matching 이다. 기존 instancof 는 비교후에 casting을 해주는 코드가 한 줄 더 들어갔는데 if (!(o instanceof Article article)) 이렇게 바로 사용할 수 있도록 추가됐다.\n더 간단한 코드 예시로 표현하면\nif (animal instanceof Cat){ Cat cat = (Cat) animal; cat.meow(); // other cat operations }else if(animal instanceof Dog){ Dog dog = (Dog) animal; dog.woof(); // other dog operations } =\u0026gt; pattern matching\nif(animal instanceof Cat cat){ cat.meow(); }else if(animal instanceof Dog dog){ dog.woof(); } ","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_jpa%EB%A1%9C_entity/","summary":"자주 사용하다보면 익숙하게 익혀지겠지만, 그래도 기록으로 남겨서 빠르게 와서 복습할 수 있도록 자세하게 남겨보도록 하려한다.\npackage com.fastcampus.springboard.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import org.springframework.data.annotation.CreatedBy; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedBy; import org.springframework.data.annotation.LastModifiedDate; import javax.persistence.*; import java.time.LocalDateTime; import java.util.LinkedHashSet; import java.util.Objects; import java.util.Set; @Getter // 전체 레벨에서는 Setter를 설정하지 말자(데이터 보호를 위해서 필요한 값만) @ToString // 쉽게 볼 수 있도록 @Table(indexes = { // 빠르게 검색할 수 있도록 인덱스 설정 @Index(columnList = \u0026#34;title\u0026#34;), @Index(columnList = \u0026#34;hashtag\u0026#34;), @Index(columnList = \u0026#34;createdAt\u0026#34;), @Index(columnList = \u0026#34;createdBy\u0026#34;), }) // Entity에도 Auditing을 사용한다는 설정을 해줘야 한다.","title":"SpringBoot JPA로 Entity 클래스 구성하기"},{"content":"Java에서 ORM 기술인 JPA 를 사용해서 도메인(엔티티)을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 예를 들면 생성일자, 생성자, 수정일자, 수정자 등의 필드 및 컬럼이 있다.\n도메인마다 공통적으로 필요하다면 결국 코드가 중복으로 작성될 수밖에 없게 되고 중복을 무척이나 싫어하는 개발자들은 이 문제를 해결하기 위해서 JPA Auditing 이라는 기능을 개발하게 됩니다.\nAudit 은 감시하다, 감사하다 라는 뜻으로 Spring Date JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능이다. 도메인(엔티티)을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update 하는 경우 매번 시간 데이터를 입력해 줘야 하는데, 이 기능을 사용하면 자동으로 시간을 매핑해서 테이블에 넣어준다.\npackage com.fastcampus.springboard.config; import org.springframework.context.annotat import org.springframework.context.annotat import org.springframework.data.domain.Aud import org.springframework.data.jpa.reposi import java.util.Optional; @EnableJpaAuditing // JPA Auditing 기능 활성화 @Configuration public class JpaConfig { @Bean public AuditorAware\u0026lt;String\u0026gt; auditorAwa return () -\u0026gt; Optional.of(\u0026#34;hiyee\u0026#34;); } } 위와 같이 config 패키지에 JpaConfig 클래스에 설정해주고 안에 설정해주고 쓰면 된다. 지금 @Bean은 아직 Spring Boot Security 가 붙지 않은 상태에서 임의로 모든 수정자의 이름을 지정해준 모습이다. Spring Boot Security가 구현된다면 수정될 부분이다.\n@CreatedDate private LocalDateTime createdAt; // 생성일시 @CreatedBy private String createdBy; // 생성자 @LastModifiedDate private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy private String modifiedBy; // 수정자 이처럼 Entity 에서 해당 부분에 해당하는 애노테이션을 달아주기만 하면 사용할 수 있다. JpaConfig 부분은 Spring Boot Security 구현 후에 이 글에 추가적으로 업데이트 할 예정이다.\nEntity 클래스에서도 Auditing을 사용한다는 애노테이션을 달아줘야 한다. Entity 클래스 위에\n@EntityListeners(AuditingEntityListener.class) 를 표시해줘야 해당 클래스에서 Auditing 기능이 동작한다\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_jpa_auditing/","summary":"Java에서 ORM 기술인 JPA 를 사용해서 도메인(엔티티)을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 예를 들면 생성일자, 생성자, 수정일자, 수정자 등의 필드 및 컬럼이 있다.\n도메인마다 공통적으로 필요하다면 결국 코드가 중복으로 작성될 수밖에 없게 되고 중복을 무척이나 싫어하는 개발자들은 이 문제를 해결하기 위해서 JPA Auditing 이라는 기능을 개발하게 됩니다.\nAudit 은 감시하다, 감사하다 라는 뜻으로 Spring Date JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능이다. 도메인(엔티티)을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update 하는 경우 매번 시간 데이터를 입력해 줘야 하는데, 이 기능을 사용하면 자동으로 시간을 매핑해서 테이블에 넣어준다.","title":"JPA Auditing"},{"content":"웹 개발을 하면서 어플리케이션을 만들 때 서비스 로직뿐만 아니라 사용자의 정보라던지 어떤 경로로 요청이 들어오는지 등 많은 것을 고려하고 개발해야 한다. spring-boot-actuator라는 모듈은 애플리케이션 상태를 종합적으로 정리해서 보여준다.\nSpring Boot Actuator 간단히 말하자면 Spring Boot Application의 상태를 관리해준다.\nSpring Boot Application의 상태정보(health, properties, beans, 구동된 AutoConfiguration 목록 등)을 다룰 수 있도록 자동으로 설정 각종 추상화 클래스(HealthIndicator 등)을 제공하여, 상태 정보를 변경할 수 있도록 Service 제공 노출할 항목 설정 # Actuator 감춰져 있는 모든 endpoint 정보 표출하도록 설정 management.endpoints.web.exposure.include: \u0026#34;*\u0026#34; # health와 metrics 정보만 노출 management.endpoints.web.exposure.include: \u0026#34;health, metrics\u0026#34; Endpoint 경로 설정 management.endpoint.web.base-path(기본값 /actuator)를 수정하여 base-path를 수정할 수 있다. management.endpoint.web.path-mapping.\u0026lt;id\u0026gt; 값을 수정하여, 특정 id의 endpoint의 경로를 수정할 수 있다. CORS spring-boot-actuator는 기본적으로 클라우드 환경에서 관리자가 애플리케이션 상태를 확인하기 쉽도록 되어 있다. 때문에 필요한 경우에 외부 도메인명을 가진 Appication에서 각각 서비스의 상태를 확인하기 위해서 정보를 요청할 수 있다. 그럴 경우 CORS를 설정해서 사용할 수 있다.\nmanagement.endpoints.web.cors.allowed-origins=http://other-domain.com management.endpoints.web.cors.allowed-methods=GET,POST 우선 이 기록에서는 Actuator가 무슨 기능을 가지고 있는지 확인해봤다. 추후에 기능을 추가하거나 하는 기능은 적용할 때 미디움에서 기록할 듯 싶다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_spring_actuator/","summary":"웹 개발을 하면서 어플리케이션을 만들 때 서비스 로직뿐만 아니라 사용자의 정보라던지 어떤 경로로 요청이 들어오는지 등 많은 것을 고려하고 개발해야 한다. spring-boot-actuator라는 모듈은 애플리케이션 상태를 종합적으로 정리해서 보여준다.\nSpring Boot Actuator 간단히 말하자면 Spring Boot Application의 상태를 관리해준다.\nSpring Boot Application의 상태정보(health, properties, beans, 구동된 AutoConfiguration 목록 등)을 다룰 수 있도록 자동으로 설정 각종 추상화 클래스(HealthIndicator 등)을 제공하여, 상태 정보를 변경할 수 있도록 Service 제공 노출할 항목 설정 # Actuator 감춰져 있는 모든 endpoint 정보 표출하도록 설정 management.","title":"SpringBoot Actuator"},{"content":"오늘부터 알고리즘과 코딩테스트 공부를 하면서 기록을 남겨보려고 한다 이 기록은 그냥 스스로 리뷰하기 위한 용도이므로 만약에라도 보시는 분들의 실력이 출중하시다면 볼 필요가 없는 글입니다.\n시간 복잡도 문제 해결에 소요되는 시간을 말한다\nBig-O 표기법 시간 복잡도를 표현하는 표기법\n보다시피 N의 값이 커질수록 수행시간은 비약적으로 커지므로 문제 제한 시간에 맞는 풀이법을 찾아서 풀어야한다. 어떤 알고리즘의 최소 시간과 최대 시간을 대략적으로 알고 있다면 문제해결에 서택할 알고리즘을 선택하는데 도움이 된다.\n공간 복잡도 문제를 푸는데 필요한 공간의 크기\n대부분의 코딩테스트에서 복잡도 문제로 문제를 틀리게 된다면 그건 시간 복잡도일 가능성이 대부분이기 때문에 고려하지 않아도 되는 부분이다. 그냥 512MB = 12억 integers라는 것만 기억해 두도록 하자\nData type 가장 중요한 것은 각 데이터 유형의 범위에 맞는 값을 사용해야 한다. int = 21억을 초과한다면, long long 타입을 선택해야 한다.\n실수형의 주의할 점 3가지 실수형을 저장하거나 계산할 때 에러가 발생할 수 있다. float 타입보다는 double을 쓰도록 하자 double 타입은 long long 범위의 정수를 담을 수 없다 double 타입은 15자리인데 long long 타입은 최대 19자리이다. 따라서 비슷한 16자리의 값이 저장된다. 실수형을 비교할 땐 == 사용하지 말자 ","permalink":"https://hiyee-gj.github.io/blog/posts/20230418_%EC%BD%94%ED%85%8C_%EA%B3%B5%EB%B6%80_%EA%B8%B0%EC%B4%88/","summary":"오늘부터 알고리즘과 코딩테스트 공부를 하면서 기록을 남겨보려고 한다 이 기록은 그냥 스스로 리뷰하기 위한 용도이므로 만약에라도 보시는 분들의 실력이 출중하시다면 볼 필요가 없는 글입니다.\n시간 복잡도 문제 해결에 소요되는 시간을 말한다\nBig-O 표기법 시간 복잡도를 표현하는 표기법\n보다시피 N의 값이 커질수록 수행시간은 비약적으로 커지므로 문제 제한 시간에 맞는 풀이법을 찾아서 풀어야한다. 어떤 알고리즘의 최소 시간과 최대 시간을 대략적으로 알고 있다면 문제해결에 서택할 알고리즘을 선택하는데 도움이 된다.\n공간 복잡도 문제를 푸는데 필요한 공간의 크기","title":"코테 공부 - 기초"},{"content":"Java의 정석 다시보기 멋쟁이 사자처럼 백엔드 스쿨 5기에 합격하게 되면서 Java와 Spring에 대해서 다시 찐하게 공부할 수 있는 기회를 얻게 되었다. 사실 혼자서도 공부를 지속할 수 있었겠지만 최근 알고리즘과 코딩테스트 준비로 반복적으로 문제만 풀다 보니 뭔가 의지력이 점점 소모되는게 느껴져서 더 통제되는 환경에 나를 던져놓고 나를 성장시키고 싶었는데 운이 좋게도 합격하게 되어 공부에 열정을 다시 불태울 수 있는 기회가 됐다.\n사실 자바의 정석은 작년 이맘 때쯤 좋은 스터디원 분들과 한번 1회독을 마친 책이다. 그때는 스케쥴대로 진행해야 했기 때문에 깊이 생각할 기회가 없이 지나간 느낌이고 때문에 Stream과 Collections 부분이 많이 부족하다고 느껴져서 다시 한번 읽으면서 이 블로그에 정리해 볼 생각이다.\n따라서 이 블로그에는 자바의 정석의 모든 부분이 올라오진 않는다. 예를 들어 기본적인 문법이나 변수 등의 설명은 빠질 가능성이 높다. 기존에 이해했거나 이해가 필요하지 않은 부분은 매우 빠른 속도로 지나가 예정이고, 또 실무에서 잘 사용되지 않는 기술에 대해서는 읽지 않을 생각도 있다. 그런 부분은 차후 필요할 때 읽어도 괜찮겠다는 생각이기 때문이다.\n지금은 자바의 정석으로 시작하지만 목표는 이번 멋사 기간에 자바의 정석, 토비의 스프링, 이펙티브 자바와 욕심으로는 JPA 부분까지 읽을 생각을 하고 있다.\n기존 블로그가 있음에도 Medium Blog\n이 블로그를 생성한 이유는 기존 블로그에 TIL도 섞여서 업로드하다 보니 정보성을 가진 블로그에서 많이 벗어나고 있다는 느낌이 들었다. 기존 블로그에 올렸던 PS Study 관련 글들도 다 삭제한 후에 이 블로그로 옮긴 후 TIL 관련해서는 이 블로그를 사용하고 공부하면서 느끼는 점들이나 기록해 둘 필요성이 있는 정보성 글들은 위 블로그에 기록할 예정이다. 이 블로그는 한글로 작성될 예정이고, 위 블로그는 내 형편없는 영어 실력과 영어 작문 실력의 향상을 위해서 고생하더라도 영어로 작성할 예정이다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230417_%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC_%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94_%EC%9D%B4%EC%9C%A0/","summary":"Java의 정석 다시보기 멋쟁이 사자처럼 백엔드 스쿨 5기에 합격하게 되면서 Java와 Spring에 대해서 다시 찐하게 공부할 수 있는 기회를 얻게 되었다. 사실 혼자서도 공부를 지속할 수 있었겠지만 최근 알고리즘과 코딩테스트 준비로 반복적으로 문제만 풀다 보니 뭔가 의지력이 점점 소모되는게 느껴져서 더 통제되는 환경에 나를 던져놓고 나를 성장시키고 싶었는데 운이 좋게도 합격하게 되어 공부에 열정을 다시 불태울 수 있는 기회가 됐다.\n사실 자바의 정석은 작년 이맘 때쯤 좋은 스터디원 분들과 한번 1회독을 마친 책이다.","title":"블로그를 분리하는 이유"}]