[{"content":"이 포스트는 Java 언어로 알고리즘을 풀면서 자주 사용하는 함수의 내용을 정리하는 포스트입니다.\nArrayList 깊은 복사 ArrayList를 깊은 복사하고 싶다면 복사되는배열.addAll(복사할배열) 메서드를 사용하면 된다 ArrayList\u0026lt;Integer\u0026gt; w=new ArrayList\u0026lt;Integer\u0026gt;(); ArrayList\u0026lt;Integer\u0026gt; copy_w=new ArrayList\u0026lt;Integer\u0026gt;(); copy_w.addAll(w); Sort ArrayList를 정렬할 때, 리스트명.sort() 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; ArrList=new ArrayList\u0026lt;Integer\u0026gt;(); ArrList.sort(null); Size ArrayList의 크기는 리스트명.size() 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; ArrList=new ArrayList\u0026lt;Integer\u0026gt;(); ArrList.size(); List Set =\u0026gt; List 변경 생성자에 값을 넣어주면, Set -\u0026gt; List로 변경할 수 있다 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;String\u0026gt;(); List\u0026lt;String\u0026gt; menuList = new ArrayList\u0026lt;\u0026gt;(set); Sort List를 정렬하고자 할 때, Collections.sort(리스트명) 메소드를 사용한다 List\u0026lt;Stirng\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Collections.sort(menuList); Add List에 값을 넣을 때, 리스트명.add(넣을 값) 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); remove List의 값을 삭제할 때, 리스트명.remove() 메소드를 사용한다 리스트명.remove(삭제할 값의 index) ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.remove(list.size()-1); // list의 마지막 값이 리스트에서 제거된다. Size List의 크기는 리스트명.size() 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.size(); Array Sort Array를 정렬하고자 할 때, Arrays.sort(배열 명) 메소드를 사용한다 int [] Arr=new int[5]; Arrays.sort(Arr); length Array의 길이는 배열명.length를 사용한다 int [] Arr=new int[5]; Arr.length; String to CharArray String을 char 배열로 변환할 때, toCharArray() 메소드를 사용한다 har[][] board=new char[5][5]; // String 입력을 char형 Array로 변환 for(int i=0;i\u0026lt;5;i++){ board[i]=br.readLine().toCharArray(); } // String to char Array String str=\u0026#34;12345\u0026#34;; board[0]=str.toCharArray(); System.out.println(board[0]); [출력] 12345 배열 특정 범위 자르기 배열에서 특정 범위를 자르고, 다른 배열에 저장할 때, Arrays.copyOfRange(배열명, 시작점, 끝점) 메소드를 사용한다 이 때, 범위는 [시작점, 끝점) 형식으로 시작점 이상, 끝점 미만의 범위가 설정된다 int[] array={1,2,3,4,5}; int[] temp=Arrays.copyOfRange(array,1,3); System.out.println(temp); [출력] [2,3] Array 초기화 하기 // 2차원 배열 int n = 6; int m = 7; int[][] gr = new int[n][m]; for(int i=0; i\u0026lt;n; i++) Arrays.fill(gr[i], -1); // -1로 초기화 // 1차원 배열 Arrays.fill(배열명, 초기화 값); Set 값 넣기(add) Set에 값을 넣을 때는, set명.add(넣을 값) 메소드를 사용한다 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;String\u0026gt;(); set.add(\u0026#34;combMenu\u0026#34;); 값 삭제(remove) Set에서 값을 삭제할 때는, set명.remove(삭제할 값) 메소드를 사용한다 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;String\u0026gt;(); set.remove(\u0026#34;combMenu\u0026#34;); Iterator set의 값을 조회할 때, set명.iterator()를 사용해 반복자를 생성한다 반복자.hasNext() 메소드로 다음 값이 존재하는지 확인한다 반복자.next() 메소드로 참조값을 가져온다 Set\u0026lt;String\u0026gt; set= new HashSet\u0026lt;String\u0026gt;(); set.add(\u0026#34;1\u0026#34;); set.add(\u0026#34;2\u0026#34;); set.add(\u0026#34;3\u0026#34;); Iterator\u0026lt;String\u0026gt; it= set.iterator(); while(it.hasNext()){ String a= it.next(); System.out.println(a); } [결과] 1 2 3 size set의 크기는 set명.size() 메소드를 사용한다 Map 값 넣기(put) Map에 {key : value} 값을 설정할 때, map명.put(key, value) 메소드를 사용한다 Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;str\u0026#34;,1); 값 가져오기(get) Map의 {key : value} 쌍의 value 값을 가져올 때, map명.get(key값) 메소드를 사용한다 Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.get(\u0026#34;str\u0026#34;); key 값 존재 확인(containsKey) Map에서 해당하는 key 값이 존재하는지 확인할 때, map명.containsKey(key값) 메소드를 사용한다 Key 값이 존재하면 true, 존재하지 않으면 false를 반환한다 Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.containsKey(\u0026#34;str\u0026#34;); Iterator map의 값을 조회할 때, map명.keySet().iterator()를 사용해 반복자를 생성한다 반복자.hasNext() 메소드로 다음 값이 존재하는지 확인한다 반복자.next() 메소드로 참조값을 가져온다 Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); Iterator\u0026lt;String\u0026gt; it= map.keySet().iterator(); while(it.hasNext()){ String key=it.next(); int value=map.get(key); } size Map의 크기는 map명.size()를 사용한다 Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.size(); String 소문자, 대문자 String 문자열의 문자 값을 대 -\u0026gt; 소로 변경할 때, toLowerCase() String str=\u0026#34;ABC\u0026#34;; str=str.toLowerCase(); //\u0026#34;abc\u0026#34;; String 문자열의 문자 값을 소 -\u0026gt; 대로 변경할 때, toUpperCase() String str=\u0026#34;abc\u0026#34;; str=str.toLowerCase(); //\u0026#34;ABC\u0026#34;; String to Array String str = \u0026#34;12345\u0026#34;; String[] Arr = str.split(\u0026#34;\u0026#34;); //[1,2,3,4,5] 문자열 자르기(substring) String str=\u0026#34;1234567\u0026#34;; str.substring(3); // \u0026#34;4567\u0026#34; str.substring(2,5) // \u0026#34;345\u0026#34; 문자열 뒤집기(reverse) String str = \u0026#34;Reverse\u0026#34;; String str = new StringBuilder(words).reverse().toString(); System.out.println(str); [출력] esreveR String 값 변경하기 Java에서 String은 immutable 하다. 즉 한번 할당되면 변경이 불가능하다 따라서, 특정 문자열을 변경하려면 substring 메소드를 활용해 변경된 새로운 문자열을 생성해야 한다 String name=\u0026#34;starfucks\u0026#34;; String newname=name.substring(0,4)+\u0026#39;b\u0026#39;+name.substring(5); System.out.pirntln(newname); // starbucks StringBuilder 삭제(deleteCharAt) 삭제할 때는, 빌더명.deleteCharAt(삭제할 문자의 인덱스) StringBuilder sb=new StringBuilder(); sb.append(\u0026#39;a\u0026#39;); sb.append(\u0026#39;b\u0026#39;); sb.append(\u0026#39;c\u0026#39;); System.out.println(sb); sb.deleteCharAt(1); System.out.println(sb); [출력] abc ac StringBuilder 값 변경하기 StringBuilder 객체의 특정 값을 변경할 때, 빌더명.setCharAt(인덱스, 문자) StringBuilder name = new StringBuilder(\u0026#34;starfucks\u0026#34;); name.setCharAt(4, \u0026#39;b\u0026#39;); System.out.println(name); // starbucks Pair Java에서는 Pair 연산자는 구현해서 사용한다 private static class Node{ private int x; private int y; public Node(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } } Queue\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new Node(1, 2)); Node node= queue.remove(); PriorityQueue 생성 Java에서 자료구조 PriorityQueue를 생성하는 방법 생성자에 Collections를 사용해 오름차순, 내림차순을 설정할 수 있다(default는 오름차순) import java.util.PriorityQueue; /* 오름차순 */ PriorityQueue\u0026lt;Integer\u0026gt; pq=PriorityQueue\u0026lt;Integer\u0026gt;(); PriorityQueue\u0026lt;String\u0026gt; pq=PriorityQueue\u0026lt;String\u0026gt;(); /* 내림차순 */ PriorityQeueu\u0026lt;Integer\u0026gt; pq=PriorityQueue\u0026lt;Integer\u0026gt;(Collections.reverseOrder()); Stream BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int[] arr = Stream.of(br.readLine().split(\u0026#34; \u0026#34;).mapToInt(Integer::parseInt).toArray()); Comparator // 리스트 정렬 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Collections.sort(list, Comparator.comparingInt(a -\u0026gt; a)); // 우선 순위 큐 생성 PriorityQueue\u0026lt;Integer\u0026gt; que = new PriorityQueue\u0026lt;Integer\u0026gt;(Comparator.comparingInt(o -\u0026gt; 0)); ","permalink":"https://hiyee-gj.github.io/blog/posts/20230503_java_%EC%BD%94%ED%85%8C_%ED%8C%81_%EC%A0%95%EB%A6%AC/","summary":"이 포스트는 Java 언어로 알고리즘을 풀면서 자주 사용하는 함수의 내용을 정리하는 포스트입니다.\nArrayList 깊은 복사 ArrayList를 깊은 복사하고 싶다면 복사되는배열.addAll(복사할배열) 메서드를 사용하면 된다 ArrayList\u0026lt;Integer\u0026gt; w=new ArrayList\u0026lt;Integer\u0026gt;(); ArrayList\u0026lt;Integer\u0026gt; copy_w=new ArrayList\u0026lt;Integer\u0026gt;(); copy_w.addAll(w); Sort ArrayList를 정렬할 때, 리스트명.sort() 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; ArrList=new ArrayList\u0026lt;Integer\u0026gt;(); ArrList.sort(null); Size ArrayList의 크기는 리스트명.size() 메소드를 사용한다 ArrayList\u0026lt;Integer\u0026gt; ArrList=new ArrayList\u0026lt;Integer\u0026gt;(); ArrList.size(); List Set =\u0026gt; List 변경 생성자에 값을 넣어주면, Set -\u0026gt; List로 변경할 수 있다 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;String\u0026gt;(); List\u0026lt;String\u0026gt; menuList = new ArrayList\u0026lt;\u0026gt;(set); Sort List를 정렬하고자 할 때, Collections.","title":"Java 코테 팁 정리"},{"content":"이 포스트는 알고리즘을 풀면서 Python 언어의 장점을 극대화해서 효율적으로 해결하기 위해서 학습한 내용을 모아놓은 포스트입니다\n몫과 나머지 print(a // b, a % b) ==\u0026gt; print(*divmod(a, b)) 무조건 divmod를 사용하는 게 좋은 방법은 아닙니다.\ndivmod는 작은 숫자를 다룰 때는 a//b, a%b 보다 느립니다. 대신, 큰 숫자를 다룰 때는 더 빠릅니다\nn진법으로 표기된 string을 10진법 숫자로 변환하기 int(x, base=진법) # ex) num = \u0026#39;3212\u0026#39; base = 5 ans = int(num, base) 문자열 정렬하기 s = \u0026#39;가나다라\u0026#39; n = 7 s.ljust(n) # n의 크기 안에서 좌측 정렬 s.center(n) # n의 크기 안에서 가운데 정렬 s.rjust(n) # n의 크기 안에서 오른쪽 정렬 알파벳 상수 파이썬에서는 알파벳과 숫자 모음을 상수로 정의해놓았습니다\nimport string # import 하셔야 합니다 string.ascii_lowercase # 소문자 알파벳 모음 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 알파벳 모음 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모음 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 모음 0123456789 원본을 유지한 채 정렬된 리스트 구하기 list1 = [3, 2, 5, 1] list2 = sorted(list1) ZIP 함수 잘 이용하면 복잡한 코드 없이 효율적으로 코드를 짤 수 있게 해주는 함수이다\nzip(*iterables)는 각 iterable의 요소들을 모으는 이터레이터를 만든다\n사용 예 1\nmylist = [1, 2, 3] new_list = [40, 50, 60] for i in zip(mylist, new_list): print (i) (1, 40) (2, 50) (3, 60) 사용 예 2 - 여러 개의 iterable을 순회할 때\nlist1 = [1, 2, 3, 4] list2 = [100, 120, 30, 300] list3 = [392, 2, 33, 1] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1, number2, number3) print(number1 + number2 + number3) print(\u0026#34;===========\u0026#34;) 1 100 392 493 =========== 2 120 2 124 =========== 3 30 33 66 =========== 4 300 1 305 =========== 사용 예제 3 - key 리스트와 Value 리스트로 딕셔너리 생성하기\nanimals = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;lion\u0026#39;] sounds = [\u0026#39;meow\u0026#39;, \u0026#39;woof\u0026#39;, \u0026#39;roar\u0026#39;] answer = dict(zip(animals, sounds)) # {\u0026#39;cat\u0026#39;: \u0026#39;meow\u0026#39;, \u0026#39;dog\u0026#39;: \u0026#39;woof\u0026#39;, \u0026#39;lion\u0026#39;: \u0026#39;roar\u0026#39;} zip - 2차원 리스트 뒤집기 mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) # [[1, 4, 7], [2, 5, 8], [3, 6, 9]] *mylist를 하면 안의 원소들인 리스트 인 [1, 2, 3], [4, 5, 6], [7, 8, 9]가 값으로 나오는데 그 값들을 zip으로 묶어서 map 함수로 다시 리스트로 묶어주고 그 리스트들을 다시 하나의 리스트로 묶어서 반환해준다\nzip - i번째 원소와 i+i번째 원소 보통의 풀이는 이중 for문을 사용해서 해결할 것이다\ndef solution(mylist): answer = [] for i in range(len(mylist)-1): answer.append(abs(mylist[i] - mylist[i+1])) return answer if __name__ == \u0026#39;__main__\u0026#39;: mylist = [83, 48, 13, 4, 71, 11] print(solution(mylist)) 하지만 zip 함수를 이용하면 한번의 for문으로 해결할 수 있다\ndef solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer if __name__ == \u0026#39;__main__\u0026#39;: mylist = [83, 48, 13, 4, 71, 11] print(solution(mylist)) map - 모든 멤버의 type 변환하기 map 기능을 활용하지 않으면 for문을 사용해서 풀 것이다\nlist1 = [\u0026#39;1\u0026#39;, \u0026#39;100\u0026#39;, \u0026#39;33\u0026#39;] list2 = [] for value in list1: list2.append(int(value)) ==\u0026gt;\nlist1 = [\u0026#39;1\u0026#39;, \u0026#39;100\u0026#39;, \u0026#39;33\u0026#39;] list2 = list(map(int, list1)) join - 멤버를 하나로 이어 붙이기 my_list = [\u0026#39;1\u0026#39;, \u0026#39;100\u0026#39;, \u0026#39;33\u0026#39;] answer = \u0026#39;\u0026#39;.join(my_list) product - 곱집합(cartesian product) 구하기 예시) 두 스트링 \u0026lsquo;ABCD\u0026rsquo;, \u0026lsquo;xy\u0026rsquo; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다.\nitertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다.\nimport itertools # import 필요 iterable1 = \u0026#39;ABCD\u0026#39; iterable2 = \u0026#39;xy\u0026#39; iterable3 = \u0026#39;1234\u0026#39; print(list(itertools.product(iterable1, iterable2, iterable3))) 2차원 리스트를 1차원 리스트로 만드는 방법들 my_list = [[1, 2], [3, 4], [5, 6]] # 방법 1 - sum 함수 answer = sum(my_list, []) # 방법 2 - itertools.chain import itertools list(itertools.chain.from_iterable(my_list)) # 방법 3 - itertools와 unpacking import itertools list(itertools.chain(*my_list)) # 방법 4 - list comprehension 이용 [element for array in my_list for element in array] # 방법 5 - reduce 함수 이용 1 from functools import reduce list(reduce(lambda x, y: x+y, my_list)) # 방법 6 - reduce 함수 이용 2 from functools import reduce import operator list(reduce(operator.add, my_list)) 순열과 조합 - permutations, combinations 순열 - permutations import itertools pool = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] print(list(map(\u0026#39;\u0026#39;.join, itertools.permutations(pool)))) # 3개의 원소로 순열 만들기 print(list(map(\u0026#39;\u0026#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 순열 만들기 조합 - combinations l = [1,2,3] for i in combinations(l,2): print(i) \u0026#39;\u0026#39;\u0026#39; 출력 결과: (1, 2) (1, 3) (2, 3) \u0026#39;\u0026#39;\u0026#39; 조합(중복 허용) - combinations_with_replacement from itertools import combinations_with_replacement l = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for i in combinations_with_replacement(l,2): print(i) \u0026#39;\u0026#39;\u0026#39; 출력결과: (\u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;) (\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;) (\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;) (\u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;) (\u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) (\u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;) \u0026#39;\u0026#39;\u0026#39; Counter - 가장 많이 등장하는 알파벳 찾기 알고리즘 문제를 풀다 보면 어떤 원소 x가 주어진 시퀀스타입에 몇 번이나 등장하는지 세야 할 때가 있습니다. 이 때 사용하면 좋은 클래스가 바로 Counter 입니다\nimport collections my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = collections.Counter(my_list) print(answer) # Counter({1: 4, 2: 3, 3: 3, 7: 3, 4: 2, 5: 2, 6: 2, 8: 2, 9: 2, 0: 2}) print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = 0 사용법에 대해서 궁금할 수 있을거라 생각합니다 문제 하나를 같이 풀어보면 좀 더 와닿을 거라 생각됩니다\n이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요.\ninput output \u0026lsquo;aab\u0026rsquo; \u0026lsquo;a\u0026rsquo; \u0026lsquo;dfdefdgf\u0026rsquo; \u0026lsquo;df\u0026rsquo; \u0026lsquo;bbaa\u0026rsquo; \u0026lsquo;ab\u0026rsquo; import collections # import my_list = input().strip() # 입력값 초기화 # 들어온 string 값의 각 알파벳의 Counter를 구해준다 answer = collections.Counter(my_list) # 딕셔너리 형태의 answer에서 values(나온 횟수)만 모아서 리스트를 만든다 values = [i for i in answer.values()] # 내림차순으로 정렬해준다 values.sort(reverse=True) # 가장 자주 나온 횟수를 저장해준다 big = values[0] # 딕셔너리 형태의 answer를 for문으로 k(키), v(값)으로 돌면서 # v(값) == 나온 횟수가 big(가장 자주 나온 횟수)랑 같은 k(키) == 알파벳을 찾아서 리스트에 담는다 result = [k for k, v in answer.items() if big == v] # join 함수로 나온 알파벳들을 묶어준다 result = \u0026#39;\u0026#39;.join(sorted(result)) print(result) List comprehension의 if문 - for문과 if문을 한번에 mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] flag 변수를 활용하는 대신 for-else문 사용하기 알고리즘을 풀 때, 어떤 조건에서 for문을 돌고 해당하면 flag 변수의 값을 True로 변환하고 그렇지 않으면 False로 지정해서 후처리를 하곤 한다\n하지만 for-else 문법을 사용하면 더 간단하게 처리할 수 있다\nflag 변수를 사용해서 풀 때\nimport math if __name__ == \u0026#39;__main__\u0026#39;: numbers = [int(input()) for _ in range(5)] multiplied = 1 flag = True for number in numbers: multiplied *= number if math.sqrt(multiplied) == int(math.sqrt(multiplied)): flag = False print(\u0026#39;found\u0026#39;) break if flag: print(\u0026#39;not found\u0026#39;) for-else로 풀 때\nimport math if __name__ == \u0026#39;__main__\u0026#39;: numbers = [int(input()) for _ in range(5)] multiplied = 1 for number in numbers: multiplied *= number if math.sqrt(multiplied) == int(math.sqrt(multiplied)): print(\u0026#39;found\u0026#39;) break # for문을 다 돌았을 때 조건에 해당하지 않으면 else를 실행 else: print(\u0026#39;not found\u0026#39;) 두 변수의 값 바꾸기 a = 3 b = \u0026#39;abc\u0026#39; a, b = b, a binary search - 이진 탐색하기 파이썬에서는 이진 탐색 알고리즘을 구현한 모듈이 있습니다\nimport bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 3)) 클래스 인스턴스 출력 파이썬에서는 __str__ 메소드를 사용해 class 내부에서 출력 format을 지정할 수 있습니다.\nclass Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return \u0026#39;({}, {})\u0026#39;.format(self.x, self.y) point = Coord(1, 2) print(point) \u0026#39;\u0026#39;\u0026#39; (1, 2) \u0026#39;\u0026#39;\u0026#39; inf - 가장 큰 수 inf는 어떤 숫자와 비교해도 무조건 크다고 판정됩니다.\n무한수는 float형에만 적용 가능합니다. int형에는 적용 불가능합니다.\nmin_val = float(\u0026#39;inf\u0026#39;) min_val \u0026gt; 10000000000 # 음수 기호를 붙여서 가장 작은 값도 가능합니다 max_val = float(\u0026#39;-inf\u0026#39;) 파일 입출력 간단하게 하기 파이썬의 with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다.\n파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. with open(\u0026#39;myfile.txt\u0026#39;) as file: for line in file.readlines(): print(line.strip().split(\u0026#39;\\t\u0026#39;)) ","permalink":"https://hiyee-gj.github.io/blog/posts/20230502_python%EB%8B%B5%EA%B2%8C/","summary":"이 포스트는 알고리즘을 풀면서 Python 언어의 장점을 극대화해서 효율적으로 해결하기 위해서 학습한 내용을 모아놓은 포스트입니다\n몫과 나머지 print(a // b, a % b) ==\u0026gt; print(*divmod(a, b)) 무조건 divmod를 사용하는 게 좋은 방법은 아닙니다.\ndivmod는 작은 숫자를 다룰 때는 a//b, a%b 보다 느립니다. 대신, 큰 숫자를 다룰 때는 더 빠릅니다\nn진법으로 표기된 string을 10진법 숫자로 변환하기 int(x, base=진법) # ex) num = \u0026#39;3212\u0026#39; base = 5 ans = int(num, base) 문자열 정렬하기 s = \u0026#39;가나다라\u0026#39; n = 7 s.","title":"Python답게"},{"content":"@Mock과 @MockBean Mock 객체를 선언할 때 쓰이는 어노테이션\nSpring의 ApplicationContext에 Mock 객체들을 넣어준다\n@Mock import org.mockito.Mock @MockBean import org.springframework.boo.test.mock.mockito.MockBean 스프링 테스트에서 지원 Spring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 @MockBean을 사용하고 아닌 경우에는 @Mock을 사용한다\n@Mock 필드명에 @Mock을 선언해주어 에러검증을 쉽게 하고, 해당 필드가 Mock 객체임을 더 명확하게 표시한다\nService 레이어 테스트할 때, Repository를 가짜 객체로 만드는 용도로 사용될 수 있다.\n@MockBean **@WebMvcTest**를 이용한 테스트에서 사용할 수 있다.\n@WebMvcTest는 Controller를 테스트할 때 주로 이용되며, 단일 클래스의 테스트를 진행하므로 @MockBean을 통해 가짜 객체를 만들어 준다. =\u0026gt; Controller 객체까지만 생성되고 Service 객체는 생성하지 않는다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230424_@mock_@mockbean/","summary":"@Mock과 @MockBean Mock 객체를 선언할 때 쓰이는 어노테이션\nSpring의 ApplicationContext에 Mock 객체들을 넣어준다\n@Mock import org.mockito.Mock @MockBean import org.springframework.boo.test.mock.mockito.MockBean 스프링 테스트에서 지원 Spring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 @MockBean을 사용하고 아닌 경우에는 @Mock을 사용한다\n@Mock 필드명에 @Mock을 선언해주어 에러검증을 쉽게 하고, 해당 필드가 Mock 객체임을 더 명확하게 표시한다\nService 레이어 테스트할 때, Repository를 가짜 객체로 만드는 용도로 사용될 수 있다.\n@MockBean **@WebMvcTest**를 이용한 테스트에서 사용할 수 있다.","title":"@Mock, @MockBean"},{"content":"Mock 이란 가짜 객체라고 불리며, 객체의 행위를 검증하기 위해 사용되는 가짜 객체이다\n가짜 객체를 만드는 이유 실제 객체를 만드는데 드는 시간을 절약하고, 의존성의 연결고리가 많이 연결된 경우에 구현의 복잡함을 피하고 간단하게 테스트 검증을 하기 위해서 쓴다\nTest Double 테스트 더블은 영화를 촬영할 때 배우를 대신하여 위험한 역할을 하는 스턴트 더블이라는 용어에서 유래된 단어이다\n자동화된 테스트를 작성할 때, 여러 객체들이 의존성을 갖는 경우 테스트하기 까다로운 경우가 있다. 예를 들어서 프로덕션 코드에서 Service layer는 DAO에 직접적으로 의존하고, 따라서 Database까지 의존하는 형태를 갖는다\n테스트 형태 Sociable Test 의존 관계가 간단한 경우 테스트 대상과 의존하고 있는 대상을 함께 테스트할 수 있다. Sociable Test에서 우리가 테스트하는 Service 객체는 실제로 동작하는 DAO(Repository) 객체를 통해 데이터베이스에 엑세스한다\nSolitary Test 테스트 대상이 아닌 의존성이 맺어진 대상의 결함으로 테스트가 실패하는 경우가 발생할 수 있다. 의존 대상 때문에 테스트가 실패하는 것을 막기 위해서 의존 대상 대신에 실제 동작하는 것처럼 보이는 별개의 객체를 만드는 것을 생각해볼 수 있다. 이 방식을 Solitary Test라고 한다\n이 때, 만드는 별개의 객체를 Test Double(테스트 더블) 이라고 한다. 즉, 테스트 코드에서 Service가 데이터베이스를 실제로 조작하는 DAO 대신에 가짜 DAO를 사용하게 만드는 것이다\n테스트 더블은 테스트하고자 하는 대상만 독립적으로 테스트할 수 있도록 별개로 구현한 실제 객체보다 단순한 객체를 의미한다. 테스트 대상을 SUT(System Under Test)라고 하고, SUT가 의존하고 있는 구성요소를 DOC(Depended-on Component)라고 하는데, 테스트 더블은 이 DOC와 동일한 API를 제공한다.\n테스트 더블의 종류 테스트 더블도 테스트에서 수행하는 역할에 따라서 많은 종류로 나뉜다. 대표적으로는 Dummy, Fake, Stub, Spy, Mock 5가지로 크게 분류된다.\nDummy Dummy는 아무런 동작도 하지 않는다. 주로 파라미터로 전달되기 위해서 사용된다.\n예를 들어 로깅을 하는 객체는 테스트에서는 사용되지 않을 수 있다. 그렇다면 아래와 같이 아무런 행위를 가지지 않은 Dummy를 만들어볼 수 있을 것이다.\npublic interface Logger { void log(); } public class LoggerDummy implements Logger { @Override public void log() { } } Fake Fake는 실제 동작하는 구현을 가지고 있지만, 프로덕션에서는 사용되기 적합하지 않은 객체이다.\n예를 들어 위 그림처럼 LoginService가 실제 프로덕션에서는 AccountDao에 의존하여 데이터베이스를 사용하고 있다. 하지만 테스트코드에서는 데이터베이스 대신에 HashMap을 사용하는 FakeAccountDao를 대신 LoginService에 주입하여, 데이터베이스와 연결을 끊고 테스트할 수 있다.\npublic class BoardDaoFake implements BoardDao { // 실제 dao 대신에 fake dao private final Map\u0026lt;Position, Piece\u0026gt; fakeBoard = new HashMap\u0026lt;\u0026gt;(); // ... @Override public void createPiece(RoomId roomId, Position position, Piece piece) { fakeBoard.put(position, piece); } // ... Stub Stub은 Dummy가 마치 실제로 동작하는 것처럼 보이게 만든 객체이다. 미리 반환할 데이터가 정의되어 있으며, 메소드를 호출하였을 경우 그것을 그대로 반환하는 역할만 수행한다.\nSpy 실체 객체를 부분적으로 Stubbing하면서 동시에 약간의 정보를 기록하는 객체이다. 기록하는 정보에는 메소드 호출 여부, 메소드 호출 횟수 등이 포함된다.\nMock 호출에 대한 기대를 명세할 수 있고, 그 명세 내용에 따라 동작하도록 프로그래밍된 객체이다. Mock외의 것은 개발자가 임의로 코드를 사용하여 생성할 수 있지만, Mock은 라이브러리에 의해 동적으로 생성된다. 또한 설정에 따라서 충분히 Dummy, Stub, Spy처럼 동작할 수 있어서 가장 강력한 테스트 더블이라고 할 수 있다\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230424_test_double/","summary":"Mock 이란 가짜 객체라고 불리며, 객체의 행위를 검증하기 위해 사용되는 가짜 객체이다\n가짜 객체를 만드는 이유 실제 객체를 만드는데 드는 시간을 절약하고, 의존성의 연결고리가 많이 연결된 경우에 구현의 복잡함을 피하고 간단하게 테스트 검증을 하기 위해서 쓴다\nTest Double 테스트 더블은 영화를 촬영할 때 배우를 대신하여 위험한 역할을 하는 스턴트 더블이라는 용어에서 유래된 단어이다\n자동화된 테스트를 작성할 때, 여러 객체들이 의존성을 갖는 경우 테스트하기 까다로운 경우가 있다. 예를 들어서 프로덕션 코드에서 Service layer는 DAO에 직접적으로 의존하고, 따라서 Database까지 의존하는 형태를 갖는다","title":"Test Double"},{"content":"Controller 테스트 작성 @WebMvcTest Application을 완전하게 시작학지 않고, Web layer를 테스트하고 싶을 때 @WebMvcTest를 사용한다.\nMockMvc 애플리케이션을 배포하지 않고도, 서버의 MVC 동작을 테스트하게 해주는 라이브러리다. 주로 Controller 레이어 테스트에 많이 사용된다.\n테스트 이름 정하기 테스트마다 이름에 테스트하는 조건을 넣기 때문에 따로 @DisplayName을 설정하지 않을 수도 있지만 보다 구분하기 쉽고 명확하게 하기 위해서 사용하는 것을 고려해보는게 좋다고 생각한다.\n@DisplayName(\u0026#34;[view][GET] 게시글 리스트 (게시판) 페이지 - 정상 호출\u0026#34;) 팀마다 이름 규칙을 정해서 맨 앞 부분만 보더라도 어디를 어떤 테스트를 하는 건지 구분짓는 것도 좋은 방법같다.\nController View Test하는 메서드 하나 예시 // Gradle build는 Test가 통과하지 않으면 build를 실패한다. // 개발 중인 기능으로 Test가 실패하면 안되니까 우선 테스트 메서드별로 @Disabled 처리한다 @Disabled(\u0026#34;구현 중\u0026#34;) @DisplayName(\u0026#34;[view][GET] 게시글 리스트 (게시판) 페이지 - 정상 호출\u0026#34;) @Test public void givenNothing_whenRequestingArticlesView_thenReturnsArticlesView() throws Exception { // Give // When \u0026amp; Then mvc.perform(get(\u0026#34;/articles\u0026#34;)) .andExpect(status().isOk()) .andExpect(content().contentType(MediaType.TEXT_HTML)) // model attribute에 articles라는 이름으로 넘어온 데이터가 있는지만 확인 .andExpect(model().attributeExists(\u0026#34;articles\u0026#34;)); } ","permalink":"https://hiyee-gj.github.io/blog/posts/20230422_controller_%ED%85%8C%EC%8A%A4%ED%8A%B8/","summary":"Controller 테스트 작성 @WebMvcTest Application을 완전하게 시작학지 않고, Web layer를 테스트하고 싶을 때 @WebMvcTest를 사용한다.\nMockMvc 애플리케이션을 배포하지 않고도, 서버의 MVC 동작을 테스트하게 해주는 라이브러리다. 주로 Controller 레이어 테스트에 많이 사용된다.\n테스트 이름 정하기 테스트마다 이름에 테스트하는 조건을 넣기 때문에 따로 @DisplayName을 설정하지 않을 수도 있지만 보다 구분하기 쉽고 명확하게 하기 위해서 사용하는 것을 고려해보는게 좋다고 생각한다.\n@DisplayName(\u0026#34;[view][GET] 게시글 리스트 (게시판) 페이지 - 정상 호출\u0026#34;) 팀마다 이름 규칙을 정해서 맨 앞 부분만 보더라도 어디를 어떤 테스트를 하는 건지 구분짓는 것도 좋은 방법같다.","title":"Controller 테스트 작성"},{"content":"QueryDSL 이란 QueryDSL은 HQL(Hibernate Query Language) 쿼리를 타입에 맞게 생성 및 관리할 수 있도록 도와주는 역할을 한다. SQL을 자바 코드처럼 작성할 수 있도록 해 준다\n특징 문자가 아닌 코드로 쿼리를 작성하기 때문에 컴파일 시점에서 문법 오류 발견이 된다 자동완성 등 IDE의 도움을 받을 수 있다 동적 쿼리 작성이 편리하다(여러 방법들 중에서 압도적을로 좋은 부분) 쿼리 작성 시 제약 조건 등을 메서드 화해서 재사용할 수 있다 도메인 타입과 프로퍼티를 안전하게 참조할 수 있으며, 도메인 타입의 리팩터링을 더 잘할 수 있다 아쉽게도 QueryDSL은 Spring Initializr 페이지에서는 추가할 수 없고, 직접 설치해줘야 하는데 이 때 gradle 플러그인으로 설치하는 간단한 방법은 추천하지 않는다. QueryDSL gradle plugin 해당 플러그인인데, 스프링 1 버전때부터 활발히 사용되어 오는 아주 유용한 플러그인이지만, github 주소를 가보면 업데이트 된 지 너무 오래된 플러그인이라서 추천하지 않는다.\n설치 방법 dependencies 부분 // queryDSL 설정 // collections는 그렇게 중요한 부분은 아니고 jpa,core,apt 부분은 중요한 설정이다 implementation \u0026#34;com.querydsl:querydsl-jpa\u0026#34; implementation \u0026#34;com.querydsl:querydsl-core\u0026#34; implementation \u0026#34;com.querydsl:querydsl-collections\u0026#34; annotationProcessor \u0026#34;com.querydsl:querydsl-apt:${dependencyManagement.importedProperties[\u0026#39;querydsl.version\u0026#39;]}:jpa\u0026#34; // querydsl 사용하다 보면 나오는 에러 메시지 대응하는 설정 // java.lang.NoClassDefFoundError (javax.annotation.Generated) 대응코드 annotationProcessor \u0026#34;jakarta.annotation:jakarta.annotation-api\u0026#34; // java.lang.NoClassDefFoundError (javax.annotation.Entity) 대응코드 annotationProcessor \u0026#34;jakarta.persistence:jakarta.persistence-api\u0026#34; 전역 부분 설정 // Querydsl 설정부 // QClass가 빌드 디렉토리에 들어가는데 원하는 위치에 꺼내기 위해서 // 꺼내는 이유는 Gradle이 탐색하는 영역과 intellij가 탐색하는 영역이 중복될 시 // 이미 찾은 클래스를 다시 찾아서 충돌이 나는 걸 방지하기 위해서 def generated = \u0026#39;src/main/generated\u0026#39; // 컴파일 시 querydsl QClass 파일 생성 위치를 지정 tasks.withType(JavaCompile) { options.getGeneratedSourceOutputDirectory().set(file(generated)) } // java source set 에 querydsl QClass 위치 추가 sourceSets { main.java.srcDirs += [ generated ] } // gradle clean 시에 QClass 디렉토리 삭제 clean { delete file(generated) } ","permalink":"https://hiyee-gj.github.io/blog/posts/20230421_querydsl/","summary":"QueryDSL 이란 QueryDSL은 HQL(Hibernate Query Language) 쿼리를 타입에 맞게 생성 및 관리할 수 있도록 도와주는 역할을 한다. SQL을 자바 코드처럼 작성할 수 있도록 해 준다\n특징 문자가 아닌 코드로 쿼리를 작성하기 때문에 컴파일 시점에서 문법 오류 발견이 된다 자동완성 등 IDE의 도움을 받을 수 있다 동적 쿼리 작성이 편리하다(여러 방법들 중에서 압도적을로 좋은 부분) 쿼리 작성 시 제약 조건 등을 메서드 화해서 재사용할 수 있다 도메인 타입과 프로퍼티를 안전하게 참조할 수 있으며, 도메인 타입의 리팩터링을 더 잘할 수 있다 아쉽게도 QueryDSL은 Spring Initializr 페이지에서는 추가할 수 없고, 직접 설치해줘야 하는데 이 때 gradle 플러그인으로 설치하는 간단한 방법은 추천하지 않는다.","title":"QueryDSL 설정 방법"},{"content":"debug: false # debug 전체 true 하면 너무 정보가 많아서 복잡하니까 꺼주고 # Actuator 감춰져 있는 모든 endpoint 보는 설정 # 궁금하면 찾아보도록 하자 management.endpoints.web.exposure.include: \u0026#34;*\u0026#34; # log 설정 logging: level: # 루트 패키지에서 발생하는 모든 로그들은 debug 레벨로 보겠다 com.fastcampus.springboard: debug # request, response만 볼 수 있도록 web.servlet만 debug로 켜준다 org.springframework.web.servlet: debug # jpa 사용할 때 query log를 볼 때 binding parameter들을 보기 위한 설정(기본은 ?로 표현됨) org.hibernate.type.descriptor.sql.BasicBinder: trace spring: datasource: url: jdbc:mysql://localhost:3306/board username: hiyee password: slfl4861 driver-class-name: com.mysql.cj.jdbc.Driver jpa: # 테스트용 데이터베이스 데이터를 resource 안에 넣을 수 있도록 설정(data.sql) defer-datasource-initialization: true # hibernate가 entity를 보고 ddl문을 자동으로 짜줌 hibernate.ddl-auto: create show-sql: true # 현재 설정은 jpa 구현체들은 포괄하는 spring의 추상적인 설정이라서 # hibernate에서만 있는 특징적인 property들을 설정을 해주는 부분이다. properties: # query 문을 예쁘게 formatting해서 보여주는 설정 hibernate.format_sql: true # jpa 복잡한 연관관계가 매핑되어 있는 쿼리를 사용할 때 한번에 벌크로 select 해 올 수 있도록 하는 설정 hibernate.default_batch_fetch_size: 100 # 인메모리 데이터베이스로 사용할 h2의 웹 콘솔 사용 여부 h2.console.enabled: false # resource에 만든 data.sql 작동 시기 설정 sql.init.mode: ALWAYS # rest repository 설정 data.rest: base-path: /api detection-strategy: ANNOTATED # yml 파일은 줄 세개로 여러 document 설정을 할 수 있다. --- # testdb용 설정 spring: # 테스트할 때 사용할 profile 설정 # 사용할 Test 클래스에 @ActiveProfiles(설정한 이름) config.activate.on-profile: testdb # h2 데이터 베이스는 호환성 모드를 지원하기 때문에 실제 DB와 유사한 환경을 원하면 설정해서 사용할 수 있다. datasource: # h2 데이터 베이스를 인메모리 데이터베이스로하고 mode는 MySQL로 한다 url: jdbc:h2:mem:board;mode=mysql # 드라이버 h2로 설정해주고 driverClassName: org.h2.Driver sql.init.mode: ALWAYS # 전역 설정이다 # 원래 TEST할 때 기본적으로 인메모리 DB를 자동으로 띄워서 실행하기 때문에 # 위에 내가 설정한 환경으로 실행하기 전에 먼저 기본 DB로 실행해버려서 위 설정들이 의미가 없게 된다 # Test Class에 @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) # 위 설정이 번잡하고 모든 테스트에 적용할 거라면 전역으로 설정하기 위한 부분이다. test.database.replace: none dependencies { // spring actuator - Spring Boot Application의 상태를 관리해준다. implementation \u0026#39;org.springframework.boot:spring-boot-starter-actuator\u0026#39; // spring web implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; // spring jpa - jpa 기능을 사용하도록 하는 라이브러리 implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; // rest repository - 엔티티 클래스와 레포지토리를 이용해서 바로 restful한 api 작성을 돕는 라이브러리 implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-rest\u0026#39; // Rest Repositories HAL Explorer - rest repository 기능을 쉽게 확인하고 테스트할 수 있는 라이브러리 implementation \u0026#39;org.springframework.data:spring-data-rest-hal-explorer\u0026#39; // Thymeleaf implementation \u0026#39;org.springframework.boot:spring-boot-starter-thymeleaf\u0026#39; // h2 db runtimeOnly \u0026#39;com.h2database:h2\u0026#39; // mysql db runtimeOnly \u0026#39;com.mysql:mysql-connector-j\u0026#39; // lombok compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; // lombok 관련 annotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; // Spring Boot DevTools - 프로젝트를 자동으로 재시작해주고, 정적 파일 수정 시 바로 반영해주는 라이브러리 developmentOnly \u0026#39;org.springframework.boot:spring-boot-devtools\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; } 프로젝트를 진행하면서 배우는 application 설정들에 대한 정리 글이다. 새로운게 나올 때마다 업데이트 될 예정이다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230420_application.yml/","summary":"debug: false # debug 전체 true 하면 너무 정보가 많아서 복잡하니까 꺼주고 # Actuator 감춰져 있는 모든 endpoint 보는 설정 # 궁금하면 찾아보도록 하자 management.endpoints.web.exposure.include: \u0026#34;*\u0026#34; # log 설정 logging: level: # 루트 패키지에서 발생하는 모든 로그들은 debug 레벨로 보겠다 com.fastcampus.springboard: debug # request, response만 볼 수 있도록 web.servlet만 debug로 켜준다 org.springframework.web.servlet: debug # jpa 사용할 때 query log를 볼 때 binding parameter들을 보기 위한 설정(기본은 ?로 표현됨) org.hibernate.type.descriptor.sql.BasicBinder: trace spring: datasource: url: jdbc:mysql://localhost:3306/board username: hiyee password: slfl4861 driver-class-name: com.","title":"application.yml과 build.gradle 설명"},{"content":"인메모리 DB를 이용한 Test Repository 를 이용한 테스트를 진행할 때 인메모리 DB를 많이 사용한다. 많은 방법 중 크게 2가지 정도가 자주 사용된다고 생각한다.\n@SpringBootTest + 인메모리 DB 연결 @DataJpaTest 두 방법의 차이 @DataJpaTest 는 안을 들어가 보면\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @BootstrapWith(DataJpaTestContextBootstrapper.class) @ExtendWith(SpringExtension.class) @OverrideAutoConfiguration(enabled = false) @TypeExcludeFilters(DataJpaTypeExcludeFilter.class) @Transactional @AutoConfigureCache @AutoConfigureDataJpa @AutoConfigureTestDatabase @AutoConfigureTestEntityManager @ImportAutoConfiguration meta annotation 중에서 @Transactional 이 들어가 있다. 따라서 @DataJpaTest 이 붙어있는 클래스 밑의 메서드들은 실행 시 트랜잭션이 동작하기 때문에 기본적으로 롤백된다고 보면 된다.\n@DisplayName(\u0026#34;update 테스트\u0026#34;) @Test void givenTestData_whenUpdating_thenWorksFine() { // Given Article article = articleRepository.findById(1L).orElseThrow(); String updatedHashtag = \u0026#34;#springboot\u0026#34;; article.setHashtag(updatedHashtag); // When Article savedArticle = articleRepository.save(article); // Then assertThat(savedArticle).hasFieldOrPropertyWithValue(\u0026#34;hashtag\u0026#34;, updatedHashtag); } @DataJpaTest가 붙어있다면 위와 같은 테스트 코드를 실행시키면 업데이트 쿼리가 보이지 않을 것이다. 만약 쿼리문을 확인하고 싶다면,\n@DisplayName(\u0026#34;update 테스트\u0026#34;) @Test void givenTestData_whenUpdating_thenWorksFine() { // Given Article article = articleRepository.findById(1L).orElseThrow(); String updatedHashtag = \u0026#34;#springboot\u0026#34;; article.setHashtag(updatedHashtag); // When Article savedArticle = articleRepository.saveAndFlush(article); // Then assertThat(savedArticle).hasFieldOrPropertyWithValue(\u0026#34;hashtag\u0026#34;, updatedHashtag); } save 부분을 saveAndFlush 로 바꾸면 쿼리문을 확인할 수 있다. 다만 업데이트 내용이 DB에 적용되지는 않고 마찬가지로 롤백된다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230420_@datajpatest/","summary":"인메모리 DB를 이용한 Test Repository 를 이용한 테스트를 진행할 때 인메모리 DB를 많이 사용한다. 많은 방법 중 크게 2가지 정도가 자주 사용된다고 생각한다.\n@SpringBootTest + 인메모리 DB 연결 @DataJpaTest 두 방법의 차이 @DataJpaTest 는 안을 들어가 보면\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @BootstrapWith(DataJpaTestContextBootstrapper.class) @ExtendWith(SpringExtension.class) @OverrideAutoConfiguration(enabled = false) @TypeExcludeFilters(DataJpaTypeExcludeFilter.class) @Transactional @AutoConfigureCache @AutoConfigureDataJpa @AutoConfigureTestDatabase @AutoConfigureTestEntityManager @ImportAutoConfiguration meta annotation 중에서 @Transactional 이 들어가 있다. 따라서 @DataJpaTest 이 붙어있는 클래스 밑의 메서드들은 실행 시 트랜잭션이 동작하기 때문에 기본적으로 롤백된다고 보면 된다.","title":"@DataJpaTest 기능"},{"content":"자주 사용하다보면 익숙하게 익혀지겠지만, 그래도 기록으로 남겨서 빠르게 와서 복습할 수 있도록 자세하게 남겨보도록 하려한다.\npackage com.fastcampus.springboard.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import org.springframework.data.annotation.CreatedBy; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedBy; import org.springframework.data.annotation.LastModifiedDate; import javax.persistence.*; import java.time.LocalDateTime; import java.util.LinkedHashSet; import java.util.Objects; import java.util.Set; @Getter // 전체 레벨에서는 Setter를 설정하지 말자(데이터 보호를 위해서 필요한 값만) @ToString // 쉽게 볼 수 있도록 @Table(indexes = { // 빠르게 검색할 수 있도록 인덱스 설정 @Index(columnList = \u0026#34;title\u0026#34;), @Index(columnList = \u0026#34;hashtag\u0026#34;), @Index(columnList = \u0026#34;createdAt\u0026#34;), @Index(columnList = \u0026#34;createdBy\u0026#34;), }) // Entity에도 Auditing을 사용한다는 설정을 해줘야 한다. @EntityListeners(AuditingEntityListener.class) @Entity public class Article { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Setter @Column(nullable = false) private String title; // 제목 @Setter @Column(nullable = false, length = 10000) // nullable = true가 기본설정 private String content; // 본문 // @Column은 기본 설정을 변경하는 경우가 아니라면 생략이 가능하다 @Setter private String hashtag; // 해시태그 // Jpa 양방향 설정 // mappedBy를 하지 않으면 양방향 관계의 두 테이블명을 합쳐서 테이블을 생성한다 // mappedBy로 article 테이블로부터 온 것이라고 표시해 주기 @ToString.Exclude // 순환 참조의 가능성이 있으므로 양방향 중에서 보통 one의 쪽에서 끊어준다 @OrderBy(\u0026#34;id\u0026#34;) @OneToMany(mappedBy = \u0026#34;article\u0026#34;, cascade = CascadeType.ALL) private final Set\u0026lt;ArticleComment\u0026gt; articleComments = new LinkedHashSet\u0026lt;\u0026gt;(); @CreatedDate @Column(nullable = false) private LocalDateTime createdAt; // 생성일시 @CreatedBy @Column(nullable = false, length = 100) private String createdBy; // 생성자 @LastModifiedDate @Column(nullable = false) private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy @Column(nullable = false, length = 100) private String modifiedBy; // 수정자 protected Article() { } // private 제어자로 막아놓고 팩토리 메서드로 편리하게 바로 생성하자 private Article(String title, String content, String hashtag) { this.title = title; this.content = content; this.hashtag = hashtag; } // 팩토리 메서드 public static Article of(String title, String content, String hashtag) { return new Article(title, content, hashtag); } // 그냥 lombok의 EqualsAndHashCode를 사용하면 전체 필드를 비교하기 때문에 // Entity 클래스에서는 고유값인 id만 가지고 비교하기 위해서 따로 생성해 줌 @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Article article)) return false; return id != null \u0026amp;\u0026amp; id.equals(article.id); } @Override public int hashCode() { return Objects.hash(id); } } 다른 설정들은 위 클래스를 찬찬히 보면서 기능을 익히면 되고 equals and hash 를 구현한 부분에서\n@Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Article article)) return false; return id != null \u0026amp;\u0026amp; id.equals(article.id); } 이 부분에서 if (!(o instanceof Article article)) 이 부분은 java 14 에서 추가된 pattern matching 이다. 기존 instancof 는 비교후에 casting을 해주는 코드가 한 줄 더 들어갔는데 if (!(o instanceof Article article)) 이렇게 바로 사용할 수 있도록 추가됐다.\n더 간단한 코드 예시로 표현하면\nif (animal instanceof Cat){ Cat cat = (Cat) animal; cat.meow(); // other cat operations }else if(animal instanceof Dog){ Dog dog = (Dog) animal; dog.woof(); // other dog operations } =\u0026gt; pattern matching\nif(animal instanceof Cat cat){ cat.meow(); }else if(animal instanceof Dog dog){ dog.woof(); } Auditing Field 분리하기 사실 이 부분은 팀의 규약에 따라서 다를 수도 있는 부분이다. 어떤 팀은 Entity 클래스 하나가 데이터 베이스 테이블 하나로 완전하게 일치하기를 원해서 생성일시, 생성자 등의 필드가 반복됨에도 그냥 두기를 원할 수도 있고, 어떤 팀은 반복되는 코드가 싫어서 분리할 수도 있다. 이 부분은 어떤 점이 명확히 좋다기 보다는 트레이드오프가 있는 부분이기 때문에 취향이라고 할 수 있다. 하지만 나는 공부하는 중이므로 최대한 많은 기능을 경험해 보고자 분리하는 방법도 기록해두려고 한다.\n예시로 있는 Article 클래스에서 반복적으로 사용되는\n@CreatedDate @Column(nullable = false) private LocalDateTime createdAt; // 생성일시 @CreatedBy @Column(nullable = false, length = 100) private String createdBy; // 생성자 @LastModifiedDate @Column(nullable = false) private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy @Column(nullable = false, length = 100) private String modifiedBy; // 수정자 이 부분을 분리해보려고 한다. 분리할 수 있는 방법에는 두 가지가 있는데, 첫번째는 @Embedded를 사용해서 필드화 하는 것이다. 그냥 임의의 클래스 하나를 생성하고 그 안에 중복되는 필드들을 모은 다음에 저 애노테이션을 붙이고 필드로 넣어두는 방법이다.\n@Embedded Example example; 다른 한 방법은 상속을 사용하는 방법이다.\n@Getter @ToString @EntityListeners(AuditingEntityListener.class) // Entity 클래스에 붙어있던 Auditing 설정을 가져와서 적용할 수도 있다 @MappedSuperclass public class AuditingFields { @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) // DATE_TIME에 대한 format 설정 @CreatedDate @Column(nullable = false, updatable = false) // 최초 한번만 생성되어야 하므로 updatable false 설정 private LocalDateTime createdAt; // 생성일시 @CreatedBy @Column(nullable = false, updatable = false, length = 100) private String createdBy; // 생성자 @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) @LastModifiedDate @Column(nullable = false) private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy @Column(nullable = false, length = 100) private String modifiedBy; // 수정자 } 하나의 클래스를 만든 후에 MappedSuperClass 애노테이션을 붙이고 중복 필드들을 가져온다. 여기서 Entity 클래스에 붙어있던 @EntityListeners도 가져와서 적용할 수 있다. 편리한 출력을 위해 @ToString과 @Getter를 붙였다. 중복 필드들의 값은 내가 세팅하는 값이 아니므로 당연히 @Setter는 붙이지 않았다. 이렇게 한 다음 적용은 해당 @Entity 클래스에 상속으로 시키면 된다.\npublic class Article extends AuditingFields { // 내용 } 첫 번째 방법은 필드로 사용될 클래스 명이 중요하다는 특징이 있다. 해당 클래스는 사실 데이터 베이스에는 없는 클래스인데 가져올 때 해당 클래스 타입으로 가져온 후 가공해야 하는 괴리감이 살짝 있다. 따라서 상속으로 사용하는 방법을 사용하는 게 더 좋을 것 같다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_jpa%EB%A1%9C_entity/","summary":"자주 사용하다보면 익숙하게 익혀지겠지만, 그래도 기록으로 남겨서 빠르게 와서 복습할 수 있도록 자세하게 남겨보도록 하려한다.\npackage com.fastcampus.springboard.domain; import lombok.Getter; import lombok.Setter; import lombok.ToString; import org.springframework.data.annotation.CreatedBy; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedBy; import org.springframework.data.annotation.LastModifiedDate; import javax.persistence.*; import java.time.LocalDateTime; import java.util.LinkedHashSet; import java.util.Objects; import java.util.Set; @Getter // 전체 레벨에서는 Setter를 설정하지 말자(데이터 보호를 위해서 필요한 값만) @ToString // 쉽게 볼 수 있도록 @Table(indexes = { // 빠르게 검색할 수 있도록 인덱스 설정 @Index(columnList = \u0026#34;title\u0026#34;), @Index(columnList = \u0026#34;hashtag\u0026#34;), @Index(columnList = \u0026#34;createdAt\u0026#34;), @Index(columnList = \u0026#34;createdBy\u0026#34;), }) // Entity에도 Auditing을 사용한다는 설정을 해줘야 한다.","title":"SpringBoot JPA로 Entity 클래스 구성하기"},{"content":"Java에서 ORM 기술인 JPA 를 사용해서 도메인(엔티티)을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 예를 들면 생성일자, 생성자, 수정일자, 수정자 등의 필드 및 컬럼이 있다.\n도메인마다 공통적으로 필요하다면 결국 코드가 중복으로 작성될 수밖에 없게 되고 중복을 무척이나 싫어하는 개발자들은 이 문제를 해결하기 위해서 JPA Auditing 이라는 기능을 개발하게 됩니다.\nAudit 은 감시하다, 감사하다 라는 뜻으로 Spring Date JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능이다. 도메인(엔티티)을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update 하는 경우 매번 시간 데이터를 입력해 줘야 하는데, 이 기능을 사용하면 자동으로 시간을 매핑해서 테이블에 넣어준다.\npackage com.fastcampus.springboard.config; import org.springframework.context.annotat import org.springframework.context.annotat import org.springframework.data.domain.Aud import org.springframework.data.jpa.reposi import java.util.Optional; @EnableJpaAuditing // JPA Auditing 기능 활성화 @Configuration public class JpaConfig { @Bean public AuditorAware\u0026lt;String\u0026gt; auditorAwa return () -\u0026gt; Optional.of(\u0026#34;hiyee\u0026#34;); } } 위와 같이 config 패키지에 JpaConfig 클래스에 설정해주고 안에 설정해주고 쓰면 된다. 지금 @Bean은 아직 Spring Boot Security 가 붙지 않은 상태에서 임의로 모든 수정자의 이름을 지정해준 모습이다. Spring Boot Security가 구현된다면 수정될 부분이다.\n@CreatedDate private LocalDateTime createdAt; // 생성일시 @CreatedBy private String createdBy; // 생성자 @LastModifiedDate private LocalDateTime modifiedAt; // 수정일시 @LastModifiedBy private String modifiedBy; // 수정자 이처럼 Entity 에서 해당 부분에 해당하는 애노테이션을 달아주기만 하면 사용할 수 있다. JpaConfig 부분은 Spring Boot Security 구현 후에 이 글에 추가적으로 업데이트 할 예정이다.\nEntity 클래스에서도 Auditing을 사용한다는 애노테이션을 달아줘야 한다. Entity 클래스 위에\n@EntityListeners(AuditingEntityListener.class) 를 표시해줘야 해당 클래스에서 Auditing 기능이 동작한다\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_jpa_auditing/","summary":"Java에서 ORM 기술인 JPA 를 사용해서 도메인(엔티티)을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 예를 들면 생성일자, 생성자, 수정일자, 수정자 등의 필드 및 컬럼이 있다.\n도메인마다 공통적으로 필요하다면 결국 코드가 중복으로 작성될 수밖에 없게 되고 중복을 무척이나 싫어하는 개발자들은 이 문제를 해결하기 위해서 JPA Auditing 이라는 기능을 개발하게 됩니다.\nAudit 은 감시하다, 감사하다 라는 뜻으로 Spring Date JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능이다. 도메인(엔티티)을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update 하는 경우 매번 시간 데이터를 입력해 줘야 하는데, 이 기능을 사용하면 자동으로 시간을 매핑해서 테이블에 넣어준다.","title":"JPA Auditing"},{"content":"웹 개발을 하면서 어플리케이션을 만들 때 서비스 로직뿐만 아니라 사용자의 정보라던지 어떤 경로로 요청이 들어오는지 등 많은 것을 고려하고 개발해야 한다. spring-boot-actuator라는 모듈은 애플리케이션 상태를 종합적으로 정리해서 보여준다.\nSpring Boot Actuator 간단히 말하자면 Spring Boot Application의 상태를 관리해준다.\nSpring Boot Application의 상태정보(health, properties, beans, 구동된 AutoConfiguration 목록 등)을 다룰 수 있도록 자동으로 설정 각종 추상화 클래스(HealthIndicator 등)을 제공하여, 상태 정보를 변경할 수 있도록 Service 제공 노출할 항목 설정 # Actuator 감춰져 있는 모든 endpoint 정보 표출하도록 설정 management.endpoints.web.exposure.include: \u0026#34;*\u0026#34; # health와 metrics 정보만 노출 management.endpoints.web.exposure.include: \u0026#34;health, metrics\u0026#34; Endpoint 경로 설정 management.endpoint.web.base-path(기본값 /actuator)를 수정하여 base-path를 수정할 수 있다. management.endpoint.web.path-mapping.\u0026lt;id\u0026gt; 값을 수정하여, 특정 id의 endpoint의 경로를 수정할 수 있다. CORS spring-boot-actuator는 기본적으로 클라우드 환경에서 관리자가 애플리케이션 상태를 확인하기 쉽도록 되어 있다. 때문에 필요한 경우에 외부 도메인명을 가진 Appication에서 각각 서비스의 상태를 확인하기 위해서 정보를 요청할 수 있다. 그럴 경우 CORS를 설정해서 사용할 수 있다.\nmanagement.endpoints.web.cors.allowed-origins=http://other-domain.com management.endpoints.web.cors.allowed-methods=GET,POST 우선 이 기록에서는 Actuator가 무슨 기능을 가지고 있는지 확인해봤다. 추후에 기능을 추가하거나 하는 기능은 적용할 때 미디움에서 기록할 듯 싶다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230419_spring_actuator/","summary":"웹 개발을 하면서 어플리케이션을 만들 때 서비스 로직뿐만 아니라 사용자의 정보라던지 어떤 경로로 요청이 들어오는지 등 많은 것을 고려하고 개발해야 한다. spring-boot-actuator라는 모듈은 애플리케이션 상태를 종합적으로 정리해서 보여준다.\nSpring Boot Actuator 간단히 말하자면 Spring Boot Application의 상태를 관리해준다.\nSpring Boot Application의 상태정보(health, properties, beans, 구동된 AutoConfiguration 목록 등)을 다룰 수 있도록 자동으로 설정 각종 추상화 클래스(HealthIndicator 등)을 제공하여, 상태 정보를 변경할 수 있도록 Service 제공 노출할 항목 설정 # Actuator 감춰져 있는 모든 endpoint 정보 표출하도록 설정 management.","title":"SpringBoot Actuator"},{"content":"오늘부터 알고리즘과 코딩테스트 공부를 하면서 기록을 남겨보려고 한다 이 기록은 그냥 스스로 리뷰하기 위한 용도이므로 만약에라도 보시는 분들의 실력이 출중하시다면 볼 필요가 없는 글입니다.\n시간 복잡도 문제 해결에 소요되는 시간을 말한다\nBig-O 표기법 시간 복잡도를 표현하는 표기법\n보다시피 N의 값이 커질수록 수행시간은 비약적으로 커지므로 문제 제한 시간에 맞는 풀이법을 찾아서 풀어야한다. 어떤 알고리즘의 최소 시간과 최대 시간을 대략적으로 알고 있다면 문제해결에 서택할 알고리즘을 선택하는데 도움이 된다.\n공간 복잡도 문제를 푸는데 필요한 공간의 크기\n대부분의 코딩테스트에서 복잡도 문제로 문제를 틀리게 된다면 그건 시간 복잡도일 가능성이 대부분이기 때문에 고려하지 않아도 되는 부분이다. 그냥 512MB = 12억 integers라는 것만 기억해 두도록 하자\nData type 가장 중요한 것은 각 데이터 유형의 범위에 맞는 값을 사용해야 한다. int = 21억을 초과한다면, long long 타입을 선택해야 한다.\n실수형의 주의할 점 3가지 실수형을 저장하거나 계산할 때 에러가 발생할 수 있다. float 타입보다는 double을 쓰도록 하자 double 타입은 long long 범위의 정수를 담을 수 없다 double 타입은 15자리인데 long long 타입은 최대 19자리이다. 따라서 비슷한 16자리의 값이 저장된다. 실수형을 비교할 땐 == 사용하지 말자 ","permalink":"https://hiyee-gj.github.io/blog/posts/20230418_%EC%BD%94%ED%85%8C_%EA%B3%B5%EB%B6%80_%EA%B8%B0%EC%B4%88/","summary":"오늘부터 알고리즘과 코딩테스트 공부를 하면서 기록을 남겨보려고 한다 이 기록은 그냥 스스로 리뷰하기 위한 용도이므로 만약에라도 보시는 분들의 실력이 출중하시다면 볼 필요가 없는 글입니다.\n시간 복잡도 문제 해결에 소요되는 시간을 말한다\nBig-O 표기법 시간 복잡도를 표현하는 표기법\n보다시피 N의 값이 커질수록 수행시간은 비약적으로 커지므로 문제 제한 시간에 맞는 풀이법을 찾아서 풀어야한다. 어떤 알고리즘의 최소 시간과 최대 시간을 대략적으로 알고 있다면 문제해결에 서택할 알고리즘을 선택하는데 도움이 된다.\n공간 복잡도 문제를 푸는데 필요한 공간의 크기","title":"코테 공부 - 기초"},{"content":"Java의 정석 다시보기 멋쟁이 사자처럼 백엔드 스쿨 5기에 합격하게 되면서 Java와 Spring에 대해서 다시 찐하게 공부할 수 있는 기회를 얻게 되었다. 사실 혼자서도 공부를 지속할 수 있었겠지만 최근 알고리즘과 코딩테스트 준비로 반복적으로 문제만 풀다 보니 뭔가 의지력이 점점 소모되는게 느껴져서 더 통제되는 환경에 나를 던져놓고 나를 성장시키고 싶었는데 운이 좋게도 합격하게 되어 공부에 열정을 다시 불태울 수 있는 기회가 됐다.\n사실 자바의 정석은 작년 이맘 때쯤 좋은 스터디원 분들과 한번 1회독을 마친 책이다. 그때는 스케쥴대로 진행해야 했기 때문에 깊이 생각할 기회가 없이 지나간 느낌이고 때문에 Stream과 Collections 부분이 많이 부족하다고 느껴져서 다시 한번 읽으면서 이 블로그에 정리해 볼 생각이다.\n따라서 이 블로그에는 자바의 정석의 모든 부분이 올라오진 않는다. 예를 들어 기본적인 문법이나 변수 등의 설명은 빠질 가능성이 높다. 기존에 이해했거나 이해가 필요하지 않은 부분은 매우 빠른 속도로 지나가 예정이고, 또 실무에서 잘 사용되지 않는 기술에 대해서는 읽지 않을 생각도 있다. 그런 부분은 차후 필요할 때 읽어도 괜찮겠다는 생각이기 때문이다.\n지금은 자바의 정석으로 시작하지만 목표는 이번 멋사 기간에 자바의 정석, 토비의 스프링, 이펙티브 자바와 욕심으로는 JPA 부분까지 읽을 생각을 하고 있다.\n기존 블로그가 있음에도 Medium Blog\n이 블로그를 생성한 이유는 기존 블로그에 TIL도 섞여서 업로드하다 보니 정보성을 가진 블로그에서 많이 벗어나고 있다는 느낌이 들었다. 기존 블로그에 올렸던 PS Study 관련 글들도 다 삭제한 후에 이 블로그로 옮긴 후 TIL 관련해서는 이 블로그를 사용하고 공부하면서 느끼는 점들이나 기록해 둘 필요성이 있는 정보성 글들은 위 블로그에 기록할 예정이다. 이 블로그는 한글로 작성될 예정이고, 위 블로그는 내 형편없는 영어 실력과 영어 작문 실력의 향상을 위해서 고생하더라도 영어로 작성할 예정이다.\n","permalink":"https://hiyee-gj.github.io/blog/posts/20230417_%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC_%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94_%EC%9D%B4%EC%9C%A0/","summary":"Java의 정석 다시보기 멋쟁이 사자처럼 백엔드 스쿨 5기에 합격하게 되면서 Java와 Spring에 대해서 다시 찐하게 공부할 수 있는 기회를 얻게 되었다. 사실 혼자서도 공부를 지속할 수 있었겠지만 최근 알고리즘과 코딩테스트 준비로 반복적으로 문제만 풀다 보니 뭔가 의지력이 점점 소모되는게 느껴져서 더 통제되는 환경에 나를 던져놓고 나를 성장시키고 싶었는데 운이 좋게도 합격하게 되어 공부에 열정을 다시 불태울 수 있는 기회가 됐다.\n사실 자바의 정석은 작년 이맘 때쯤 좋은 스터디원 분들과 한번 1회독을 마친 책이다.","title":"블로그를 분리하는 이유"}]