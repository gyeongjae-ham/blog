<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Test on 안녕루카</title>
    <link>https://hiyee-gj.github.io/blog/tags/test/</link>
    <description>Recent content in Test on 안녕루카</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 24 Apr 2023 23:06:29 +0900</lastBuildDate><atom:link href="https://hiyee-gj.github.io/blog/tags/test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>@Mock, @MockBean</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230424_@mock_@mockbean/</link>
      <pubDate>Mon, 24 Apr 2023 23:06:29 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230424_@mock_@mockbean/</guid>
      <description>@Mock과 @MockBean Mock 객체를 선언할 때 쓰이는 어노테이션
Spring의 ApplicationContext에 Mock 객체들을 넣어준다
@Mock import org.mockito.Mock @MockBean import org.springframework.boo.test.mock.mockito.MockBean 스프링 테스트에서 지원 Spring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 @MockBean을 사용하고 아닌 경우에는 @Mock을 사용한다
@Mock 필드명에 @Mock을 선언해주어 에러검증을 쉽게 하고, 해당 필드가 Mock 객체임을 더 명확하게 표시한다
Service 레이어 테스트할 때, Repository를 가짜 객체로 만드는 용도로 사용될 수 있다.
@MockBean **@WebMvcTest**를 이용한 테스트에서 사용할 수 있다.</description>
    </item>
    
    <item>
      <title>Test Double</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230424_test_double/</link>
      <pubDate>Mon, 24 Apr 2023 22:23:00 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230424_test_double/</guid>
      <description>Mock 이란 가짜 객체라고 불리며, 객체의 행위를 검증하기 위해 사용되는 가짜 객체이다
가짜 객체를 만드는 이유 실제 객체를 만드는데 드는 시간을 절약하고, 의존성의 연결고리가 많이 연결된 경우에 구현의 복잡함을 피하고 간단하게 테스트 검증을 하기 위해서 쓴다
Test Double 테스트 더블은 영화를 촬영할 때 배우를 대신하여 위험한 역할을 하는 스턴트 더블이라는 용어에서 유래된 단어이다
자동화된 테스트를 작성할 때, 여러 객체들이 의존성을 갖는 경우 테스트하기 까다로운 경우가 있다. 예를 들어서 프로덕션 코드에서 Service layer는 DAO에 직접적으로 의존하고, 따라서 Database까지 의존하는 형태를 갖는다</description>
    </item>
    
    <item>
      <title>Controller 테스트 작성</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230422_controller_%ED%85%8C%EC%8A%A4%ED%8A%B8/</link>
      <pubDate>Sat, 22 Apr 2023 18:41:45 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230422_controller_%ED%85%8C%EC%8A%A4%ED%8A%B8/</guid>
      <description>Controller 테스트 작성 @WebMvcTest Application을 완전하게 시작학지 않고, Web layer를 테스트하고 싶을 때 @WebMvcTest를 사용한다.
MockMvc 애플리케이션을 배포하지 않고도, 서버의 MVC 동작을 테스트하게 해주는 라이브러리다. 주로 Controller 레이어 테스트에 많이 사용된다.
테스트 이름 정하기 테스트마다 이름에 테스트하는 조건을 넣기 때문에 따로 @DisplayName을 설정하지 않을 수도 있지만 보다 구분하기 쉽고 명확하게 하기 위해서 사용하는 것을 고려해보는게 좋다고 생각한다.
@DisplayName(&amp;#34;[view][GET] 게시글 리스트 (게시판) 페이지 - 정상 호출&amp;#34;) 팀마다 이름 규칙을 정해서 맨 앞 부분만 보더라도 어디를 어떤 테스트를 하는 건지 구분짓는 것도 좋은 방법같다.</description>
    </item>
    
    <item>
      <title>@DataJpaTest 기능</title>
      <link>https://hiyee-gj.github.io/blog/posts/20230420_@datajpatest/</link>
      <pubDate>Thu, 20 Apr 2023 17:28:15 +0900</pubDate>
      
      <guid>https://hiyee-gj.github.io/blog/posts/20230420_@datajpatest/</guid>
      <description>인메모리 DB를 이용한 Test Repository 를 이용한 테스트를 진행할 때 인메모리 DB를 많이 사용한다. 많은 방법 중 크게 2가지 정도가 자주 사용된다고 생각한다.
@SpringBootTest + 인메모리 DB 연결 @DataJpaTest 두 방법의 차이 @DataJpaTest 는 안을 들어가 보면
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @BootstrapWith(DataJpaTestContextBootstrapper.class) @ExtendWith(SpringExtension.class) @OverrideAutoConfiguration(enabled = false) @TypeExcludeFilters(DataJpaTypeExcludeFilter.class) @Transactional @AutoConfigureCache @AutoConfigureDataJpa @AutoConfigureTestDatabase @AutoConfigureTestEntityManager @ImportAutoConfiguration meta annotation 중에서 @Transactional 이 들어가 있다. 따라서 @DataJpaTest 이 붙어있는 클래스 밑의 메서드들은 실행 시 트랜잭션이 동작하기 때문에 기본적으로 롤백된다고 보면 된다.</description>
    </item>
    
  </channel>
</rss>
